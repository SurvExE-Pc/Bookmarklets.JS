javascript:(function()%7B%2F%2FCreate Blob to - CC SurvExE-Pc github 2019-2022%0Afunction cbto(a)%7Bblob%3Dnew Blob(%5Ba%5D%2C%7Btype%3A"text document"%7D)%3B(windowx%3Dwindow.open("data%3Atext%2Fplain%2C")).location%3DURL.createObjectURL(blob)%7D%3B%0A%2F*%0A%09JavaScript BigInteger library version 0.9%0A%09http%3A%2F%2Fsilentmatt.com%2Fbiginteger%2F%0A%0A%09Copyright (c) 2009 Matthew Crumley <email%40matthewcrumley.com>%0A%09Copyright (c) 2010%2C2011 by John Tobey <John.Tobey%40gmail.com>%0A%09Licensed under the MIT license.%0A%0A%09Support for arbitrary internal representation base was added by%0A%09Vitaly Magerya.%0A*%2F%0A%0A%2F*%0A%09File%3A biginteger.js%0A%0A%09Exports%3A%0A%0A%09%09<BigInteger>%0A*%2F%0Avar biginteger %3D %7B%7D%3B%0A(function(exports) %7B%0A"use strict"%3B%0A%2F*%0A%09Class%3A BigInteger%0A%09An arbitrarily-large integer.%0A%0A%09<BigInteger> objects should be considered immutable. None of the "built-in"%0A%09methods modify *this* or their arguments. All properties should be%0A%09considered private.%0A%0A%09All the methods of <BigInteger> instances can be called "statically". The%0A%09static versions are convenient if you don't already have a <BigInteger>%0A%09object.%0A%0A%09As an example%2C these calls are equivalent.%0A%0A%09> BigInteger(4).multiply(5)%3B %2F%2F returns BigInteger(20)%3B%0A%09> BigInteger.multiply(4%2C 5)%3B %2F%2F returns BigInteger(20)%3B%0A%0A%09> var a %3D 42%3B%0A%09> var a %3D BigInteger.toJSValue("0b101010")%3B %2F%2F Not completely useless...%0A*%2F%0A%0Avar CONSTRUCT %3D %7B%7D%3B %2F%2F Unique token to call "private" version of constructor%0A%0A%2F*%0A%09Constructor%3A BigInteger()%0A%09Convert a value to a <BigInteger>.%0A%0A%09Although <BigInteger()> is the constructor for <BigInteger> objects%2C it is%0A%09best not to call it as a constructor. If *n* is a <BigInteger> object%2C it is%0A%09simply returned as-is. Otherwise%2C <BigInteger()> is equivalent to <parse>%0A%09without a radix argument.%0A%0A%09> var n0 %3D BigInteger()%3B      %2F%2F Same as <BigInteger.ZERO>%0A%09> var n1 %3D BigInteger("123")%3B %2F%2F Create a new <BigInteger> with value 123%0A%09> var n2 %3D BigInteger(123)%3B   %2F%2F Create a new <BigInteger> with value 123%0A%09> var n3 %3D BigInteger(n2)%3B    %2F%2F Return n2%2C unchanged%0A%0A%09The constructor form only takes an array and a sign. *n* must be an%0A%09array of numbers in little-endian order%2C where each digit is between 0%0A%09and BigInteger.base.  The second parameter sets the sign%3A -1 for%0A%09negative%2C %2B1 for positive%2C or 0 for zero. The array is *not copied and%0A%09may be modified*. If the array contains only zeros%2C the sign parameter%0A%09is ignored and is forced to zero.%0A%0A%09> new BigInteger(%5B5%5D%2C -1)%3A create a new BigInteger with value -5%0A%0A%09Parameters%3A%0A%0A%09%09n - Value to convert to a <BigInteger>.%0A%0A%09Returns%3A%0A%0A%09%09A <BigInteger> value.%0A%0A%09See Also%3A%0A%0A%09%09<parse>%2C <BigInteger>%0A*%2F%0Afunction BigInteger(n%2C s%2C token) %7B%0A%09if (token !%3D%3D CONSTRUCT) %7B%0A%09%09if (n instanceof BigInteger) %7B%0A%09%09%09return n%3B%0A%09%09%7D%0A%09%09else if (typeof n %3D%3D%3D "undefined") %7B%0A%09%09%09return ZERO%3B%0A%09%09%7D%0A%09%09return BigInteger.parse(n)%3B%0A%09%7D%0A%0A%09n %3D n %7C%7C %5B%5D%3B  %2F%2F Provide the nullary constructor for subclasses.%0A%09while (n.length %26%26 !n%5Bn.length - 1%5D) %7B%0A%09%09--n.length%3B%0A%09%7D%0A%09this._d %3D n%3B%0A%09this._s %3D n.length %3F (s %7C%7C 1) %3A 0%3B%0A%7D%0A%0ABigInteger._construct %3D function(n%2C s) %7B%0A%09return new BigInteger(n%2C s%2C CONSTRUCT)%3B%0A%7D%3B%0A%0A%2F%2F Base-10 speedup hacks in parse%2C toString%2C exp10 and log functions%0A%2F%2F require base to be a power of 10. 10%5E7 is the largest such power%0A%2F%2F that won't cause a precision loss when digits are multiplied.%0Avar BigInteger_base %3D 10000000%3B%0Avar BigInteger_base_log10 %3D 7%3B%0A%0ABigInteger.base %3D BigInteger_base%3B%0ABigInteger.base_log10 %3D BigInteger_base_log10%3B%0A%0Avar ZERO %3D new BigInteger(%5B%5D%2C 0%2C CONSTRUCT)%3B%0A%2F%2F Constant%3A ZERO%0A%2F%2F <BigInteger> 0.%0ABigInteger.ZERO %3D ZERO%3B%0A%0Avar ONE %3D new BigInteger(%5B1%5D%2C 1%2C CONSTRUCT)%3B%0A%2F%2F Constant%3A ONE%0A%2F%2F <BigInteger> 1.%0ABigInteger.ONE %3D ONE%3B%0A%0Avar M_ONE %3D new BigInteger(ONE._d%2C -1%2C CONSTRUCT)%3B%0A%2F%2F Constant%3A M_ONE%0A%2F%2F <BigInteger> -1.%0ABigInteger.M_ONE %3D M_ONE%3B%0A%0A%2F%2F Constant%3A _0%0A%2F%2F Shortcut for <ZERO>.%0ABigInteger._0 %3D ZERO%3B%0A%0A%2F%2F Constant%3A _1%0A%2F%2F Shortcut for <ONE>.%0ABigInteger._1 %3D ONE%3B%0A%0A%2F*%0A%09Constant%3A small%0A%09Array of <BigIntegers> from 0 to 36.%0A%0A%09These are used internally for parsing%2C but useful when you need a "small"%0A%09<BigInteger>.%0A%0A%09See Also%3A%0A%0A%09%09<ZERO>%2C <ONE>%2C <_0>%2C <_1>%0A*%2F%0ABigInteger.small %3D %5B%0A%09ZERO%2C%0A%09ONE%2C%0A%09%2F* Assuming BigInteger_base > 36 *%2F%0A%09new BigInteger( %5B2%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger( %5B3%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger( %5B4%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger( %5B5%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger( %5B6%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger( %5B7%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger( %5B8%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger( %5B9%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B10%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B11%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B12%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B13%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B14%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B15%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B16%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B17%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B18%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B19%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B20%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B21%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B22%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B23%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B24%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B25%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B26%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B27%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B28%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B29%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B30%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B31%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B32%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B33%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B34%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B35%5D%2C 1%2C CONSTRUCT)%2C%0A%09new BigInteger(%5B36%5D%2C 1%2C CONSTRUCT)%0A%5D%3B%0A%0A%2F%2F Used for parsing%2Fradix conversion%0ABigInteger.digits %3D "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("")%3B%0A%0A%2F*%0A%09Method%3A toString%0A%09Convert a <BigInteger> to a string.%0A%0A%09When *base* is greater than 10%2C letters are upper case.%0A%0A%09Parameters%3A%0A%0A%09%09base - Optional base to represent the number in (default is base 10).%0A%09%09       Must be between 2 and 36 inclusive%2C or an Error will be thrown.%0A%0A%09Returns%3A%0A%0A%09%09The string representation of the <BigInteger>.%0A*%2F%0ABigInteger.prototype.toString %3D function(base) %7B%0A%09base %3D %2Bbase %7C%7C 10%3B%0A%09if (base < 2 %7C%7C base > 36) %7B%0A%09%09throw new Error("illegal radix " %2B base %2B ".")%3B%0A%09%7D%0A%09if (this._s %3D%3D%3D 0) %7B%0A%09%09return "0"%3B%0A%09%7D%0A%09if (base %3D%3D%3D 10) %7B%0A%09%09var str %3D this._s < 0 %3F "-" %3A ""%3B%0A%09%09str %2B%3D this._d%5Bthis._d.length - 1%5D.toString()%3B%0A%09%09for (var i %3D this._d.length - 2%3B i >%3D 0%3B i--) %7B%0A%09%09%09var group %3D this._d%5Bi%5D.toString()%3B%0A%09%09%09while (group.length < BigInteger_base_log10) group %3D '0' %2B group%3B%0A%09%09%09str %2B%3D group%3B%0A%09%09%7D%0A%09%09return str%3B%0A%09%7D%0A%09else %7B%0A%09%09var numerals %3D BigInteger.digits%3B%0A%09%09base %3D BigInteger.small%5Bbase%5D%3B%0A%09%09var sign %3D this._s%3B%0A%0A%09%09var n %3D this.abs()%3B%0A%09%09var digits %3D %5B%5D%3B%0A%09%09var digit%3B%0A%0A%09%09while (n._s !%3D%3D 0) %7B%0A%09%09%09var divmod %3D n.divRem(base)%3B%0A%09%09%09n %3D divmod%5B0%5D%3B%0A%09%09%09digit %3D divmod%5B1%5D%3B%0A%09%09%09%2F%2F TODO%3A This could be changed to unshift instead of reversing at the end.%0A%09%09%09%2F%2F Benchmark both to compare speeds.%0A%09%09%09digits.push(numerals%5Bdigit.valueOf()%5D)%3B%0A%09%09%7D%0A%09%09return (sign < 0 %3F "-" %3A "") %2B digits.reverse().join("")%3B%0A%09%7D%0A%7D%3B%0A%0A%2F%2F Verify strings for parsing%0ABigInteger.radixRegex %3D %5B%0A%09%2F%5E%24%2F%2C%0A%09%2F%5E%24%2F%2C%0A%09%2F%5E%5B01%5D*%24%2F%2C%0A%09%2F%5E%5B012%5D*%24%2F%2C%0A%09%2F%5E%5B0-3%5D*%24%2F%2C%0A%09%2F%5E%5B0-4%5D*%24%2F%2C%0A%09%2F%5E%5B0-5%5D*%24%2F%2C%0A%09%2F%5E%5B0-6%5D*%24%2F%2C%0A%09%2F%5E%5B0-7%5D*%24%2F%2C%0A%09%2F%5E%5B0-8%5D*%24%2F%2C%0A%09%2F%5E%5B0-9%5D*%24%2F%2C%0A%09%2F%5E%5B0-9aA%5D*%24%2F%2C%0A%09%2F%5E%5B0-9abAB%5D*%24%2F%2C%0A%09%2F%5E%5B0-9abcABC%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-dA-D%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-eA-E%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-fA-F%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-gA-G%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-hA-H%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-iA-I%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-jA-J%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-kA-K%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-lA-L%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-mA-M%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-nA-N%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-oA-O%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-pA-P%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-qA-Q%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-rA-R%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-sA-S%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-tA-T%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-uA-U%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-vA-V%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-wA-W%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-xA-X%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-yA-Y%5D*%24%2F%2C%0A%09%2F%5E%5B0-9a-zA-Z%5D*%24%2F%0A%5D%3B%0A%0A%2F*%0A%09Function%3A parse%0A%09Parse a string into a <BigInteger>.%0A%0A%09*base* is optional but%2C if provided%2C must be from 2 to 36 inclusive. If%0A%09*base* is not provided%2C it will be guessed based on the leading characters%0A%09of *s* as follows%3A%0A%0A%09- "0x" or "0X"%3A *base* %3D 16%0A%09- "0c" or "0C"%3A *base* %3D 8%0A%09- "0b" or "0B"%3A *base* %3D 2%0A%09- else%3A *base* %3D 10%0A%0A%09If no base is provided%2C or *base* is 10%2C the number can be in exponential%0A%09form. For example%2C these are all valid%3A%0A%0A%09> BigInteger.parse("1e9")%3B              %2F%2F Same as "1000000000"%0A%09> BigInteger.parse("1.234*10%5E3")%3B       %2F%2F Same as 1234%0A%09> BigInteger.parse("56789 * 10 ** -2")%3B %2F%2F Same as 567%0A%0A%09If any characters fall outside the range defined by the radix%2C an exception%0A%09will be thrown.%0A%0A%09Parameters%3A%0A%0A%09%09s - The string to parse.%0A%09%09base - Optional radix (default is to guess based on *s*).%0A%0A%09Returns%3A%0A%0A%09%09a <BigInteger> instance.%0A*%2F%0ABigInteger.parse %3D function(s%2C base) %7B%0A%09%2F%2F Expands a number in exponential form to decimal form.%0A%09%2F%2F expandExponential("-13.441*10%5E5") %3D%3D%3D "1344100"%3B%0A%09%2F%2F expandExponential("1.12300e-1") %3D%3D%3D "0.112300"%3B%0A%09%2F%2F expandExponential(1000000000000000000000000000000) %3D%3D%3D "1000000000000000000000000000000"%3B%0A%09function expandExponential(str) %7B%0A%09%09str %3D str.replace(%2F%5Cs*%5B*xX%5D%5Cs*10%5Cs*(%5C%5E%7C%5C*%5C*)%5Cs*%2F%2C "e")%3B%0A%0A%09%09return str.replace(%2F%5E(%5B%2B%5C-%5D)%3F(%5Cd%2B)%5C.%3F(%5Cd*)%5BeE%5D(%5B%2B%5C-%5D%3F%5Cd%2B)%24%2F%2C function(x%2C s%2C n%2C f%2C c) %7B%0A%09%09%09c %3D %2Bc%3B%0A%09%09%09var l %3D c < 0%3B%0A%09%09%09var i %3D n.length %2B c%3B%0A%09%09%09x %3D (l %3F n %3A f).length%3B%0A%09%09%09c %3D ((c %3D Math.abs(c)) >%3D x %3F c - x %2B l %3A 0)%3B%0A%09%09%09var z %3D (new Array(c %2B 1)).join("0")%3B%0A%09%09%09var r %3D n %2B f%3B%0A%09%09%09return (s %7C%7C "") %2B (l %3F r %3D z %2B r %3A r %2B%3D z).substr(0%2C i %2B%3D l %3F z.length %3A 0) %2B (i < r.length %3F "." %2B r.substr(i) %3A "")%3B%0A%09%09%7D)%3B%0A%09%7D%0A%0A%09s %3D s.toString()%3B%0A%09if (typeof base %3D%3D%3D "undefined" %7C%7C %2Bbase %3D%3D%3D 10) %7B%0A%09%09s %3D expandExponential(s)%3B%0A%09%7D%0A%0A%09var prefixRE%3B%0A%09if (typeof base %3D%3D%3D "undefined") %7B%0A%09%09prefixRE %3D '0%5Bxcb%5D'%3B%0A%09%7D%0A%09else if (base %3D%3D 16) %7B%0A%09%09prefixRE %3D '0x'%3B%0A%09%7D%0A%09else if (base %3D%3D 8) %7B%0A%09%09prefixRE %3D '0c'%3B%0A%09%7D%0A%09else if (base %3D%3D 2) %7B%0A%09%09prefixRE %3D '0b'%3B%0A%09%7D%0A%09else %7B%0A%09%09prefixRE %3D ''%3B%0A%09%7D%0A%09var parts %3D new RegExp('%5E(%5B%2B%5C%5C-%5D%3F)(' %2B prefixRE %2B ')%3F(%5B0-9a-z%5D*)(%3F%3A%5C%5C.%5C%5Cd*)%3F%24'%2C 'i').exec(s)%3B%0A%09if (parts) %7B%0A%09%09var sign %3D parts%5B1%5D %7C%7C "%2B"%3B%0A%09%09var baseSection %3D parts%5B2%5D %7C%7C ""%3B%0A%09%09var digits %3D parts%5B3%5D %7C%7C ""%3B%0A%0A%09%09if (typeof base %3D%3D%3D "undefined") %7B%0A%09%09%09%2F%2F Guess base%0A%09%09%09if (baseSection %3D%3D%3D "0x" %7C%7C baseSection %3D%3D%3D "0X") %7B %2F%2F Hex%0A%09%09%09%09base %3D 16%3B%0A%09%09%09%7D%0A%09%09%09else if (baseSection %3D%3D%3D "0c" %7C%7C baseSection %3D%3D%3D "0C") %7B %2F%2F Octal%0A%09%09%09%09base %3D 8%3B%0A%09%09%09%7D%0A%09%09%09else if (baseSection %3D%3D%3D "0b" %7C%7C baseSection %3D%3D%3D "0B") %7B %2F%2F Binary%0A%09%09%09%09base %3D 2%3B%0A%09%09%09%7D%0A%09%09%09else %7B%0A%09%09%09%09base %3D 10%3B%0A%09%09%09%7D%0A%09%09%7D%0A%09%09else if (base < 2 %7C%7C base > 36) %7B%0A%09%09%09throw new Error("Illegal radix " %2B base %2B ".")%3B%0A%09%09%7D%0A%0A%09%09base %3D %2Bbase%3B%0A%0A%09%09%2F%2F Check for digits outside the range%0A%09%09if (!(BigInteger.radixRegex%5Bbase%5D.test(digits))) %7B%0A%09%09%09throw new Error("Bad digit for radix " %2B base)%3B%0A%09%09%7D%0A%0A%09%09%2F%2F Strip leading zeros%2C and convert to array%0A%09%09digits %3D digits.replace(%2F%5E0%2B%2F%2C "").split("")%3B%0A%09%09if (digits.length %3D%3D%3D 0) %7B%0A%09%09%09return ZERO%3B%0A%09%09%7D%0A%0A%09%09%2F%2F Get the sign (we know it's not zero)%0A%09%09sign %3D (sign %3D%3D%3D "-") %3F -1 %3A 1%3B%0A%0A%09%09%2F%2F Optimize 10%0A%09%09if (base %3D%3D 10) %7B%0A%09%09%09var d %3D %5B%5D%3B%0A%09%09%09while (digits.length >%3D BigInteger_base_log10) %7B%0A%09%09%09%09d.push(parseInt(digits.splice(digits.length-BigInteger.base_log10%2C BigInteger.base_log10).join('')%2C 10))%3B%0A%09%09%09%7D%0A%09%09%09d.push(parseInt(digits.join('')%2C 10))%3B%0A%09%09%09return new BigInteger(d%2C sign%2C CONSTRUCT)%3B%0A%09%09%7D%0A%0A%09%09%2F%2F Do the conversion%0A%09%09var d %3D ZERO%3B%0A%09%09base %3D BigInteger.small%5Bbase%5D%3B%0A%09%09var small %3D BigInteger.small%3B%0A%09%09for (var i %3D 0%3B i < digits.length%3B i%2B%2B) %7B%0A%09%09%09d %3D d.multiply(base).add(small%5BparseInt(digits%5Bi%5D%2C 36)%5D)%3B%0A%09%09%7D%0A%09%09return new BigInteger(d._d%2C sign%2C CONSTRUCT)%3B%0A%09%7D%0A%09else %7B%0A%09%09throw new Error("Invalid BigInteger format%3A " %2B s)%3B%0A%09%7D%0A%7D%3B%0A%0A%2F*%0A%09Function%3A add%0A%09Add two <BigIntegers>.%0A%0A%09Parameters%3A%0A%0A%09%09n - The number to add to *this*. Will be converted to a <BigInteger>.%0A%0A%09Returns%3A%0A%0A%09%09The numbers added together.%0A%0A%09See Also%3A%0A%0A%09%09<subtract>%2C <multiply>%2C <quotient>%2C <next>%0A*%2F%0ABigInteger.prototype.add %3D function(n) %7B%0A%09if (this._s %3D%3D%3D 0) %7B%0A%09%09return BigInteger(n)%3B%0A%09%7D%0A%0A%09n %3D BigInteger(n)%3B%0A%09if (n._s %3D%3D%3D 0) %7B%0A%09%09return this%3B%0A%09%7D%0A%09if (this._s !%3D%3D n._s) %7B%0A%09%09n %3D n.negate()%3B%0A%09%09return this.subtract(n)%3B%0A%09%7D%0A%0A%09var a %3D this._d%3B%0A%09var b %3D n._d%3B%0A%09var al %3D a.length%3B%0A%09var bl %3D b.length%3B%0A%09var sum %3D new Array(Math.max(al%2C bl) %2B 1)%3B%0A%09var size %3D Math.min(al%2C bl)%3B%0A%09var carry %3D 0%3B%0A%09var digit%3B%0A%0A%09for (var i %3D 0%3B i < size%3B i%2B%2B) %7B%0A%09%09digit %3D a%5Bi%5D %2B b%5Bi%5D %2B carry%3B%0A%09%09sum%5Bi%5D %3D digit %25 BigInteger_base%3B%0A%09%09carry %3D (digit %2F BigInteger_base) %7C 0%3B%0A%09%7D%0A%09if (bl > al) %7B%0A%09%09a %3D b%3B%0A%09%09al %3D bl%3B%0A%09%7D%0A%09for (i %3D size%3B carry %26%26 i < al%3B i%2B%2B) %7B%0A%09%09digit %3D a%5Bi%5D %2B carry%3B%0A%09%09sum%5Bi%5D %3D digit %25 BigInteger_base%3B%0A%09%09carry %3D (digit %2F BigInteger_base) %7C 0%3B%0A%09%7D%0A%09if (carry) %7B%0A%09%09sum%5Bi%5D %3D carry%3B%0A%09%7D%0A%0A%09for ( %3B i < al%3B i%2B%2B) %7B%0A%09%09sum%5Bi%5D %3D a%5Bi%5D%3B%0A%09%7D%0A%0A%09return new BigInteger(sum%2C this._s%2C CONSTRUCT)%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A negate%0A%09Get the additive inverse of a <BigInteger>.%0A%0A%09Returns%3A%0A%0A%09%09A <BigInteger> with the same magnatude%2C but with the opposite sign.%0A%0A%09See Also%3A%0A%0A%09%09<abs>%0A*%2F%0ABigInteger.prototype.negate %3D function() %7B%0A%09return new BigInteger(this._d%2C (-this._s) %7C 0%2C CONSTRUCT)%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A abs%0A%09Get the absolute value of a <BigInteger>.%0A%0A%09Returns%3A%0A%0A%09%09A <BigInteger> with the same magnatude%2C but always positive (or zero).%0A%0A%09See Also%3A%0A%0A%09%09<negate>%0A*%2F%0ABigInteger.prototype.abs %3D function() %7B%0A%09return (this._s < 0) %3F this.negate() %3A this%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A subtract%0A%09Subtract two <BigIntegers>.%0A%0A%09Parameters%3A%0A%0A%09%09n - The number to subtract from *this*. Will be converted to a <BigInteger>.%0A%0A%09Returns%3A%0A%0A%09%09The *n* subtracted from *this*.%0A%0A%09See Also%3A%0A%0A%09%09<add>%2C <multiply>%2C <quotient>%2C <prev>%0A*%2F%0ABigInteger.prototype.subtract %3D function(n) %7B%0A%09if (this._s %3D%3D%3D 0) %7B%0A%09%09return BigInteger(n).negate()%3B%0A%09%7D%0A%0A%09n %3D BigInteger(n)%3B%0A%09if (n._s %3D%3D%3D 0) %7B%0A%09%09return this%3B%0A%09%7D%0A%09if (this._s !%3D%3D n._s) %7B%0A%09%09n %3D n.negate()%3B%0A%09%09return this.add(n)%3B%0A%09%7D%0A%0A%09var m %3D this%3B%0A%09%2F%2F negative - negative %3D> -%7Ca%7C - -%7Cb%7C %3D> -%7Ca%7C %2B %7Cb%7C %3D> %7Cb%7C - %7Ca%7C%0A%09if (this._s < 0) %7B%0A%09%09m %3D new BigInteger(n._d%2C 1%2C CONSTRUCT)%3B%0A%09%09n %3D new BigInteger(this._d%2C 1%2C CONSTRUCT)%3B%0A%09%7D%0A%0A%09%2F%2F Both are positive %3D> a - b%0A%09var sign %3D m.compareAbs(n)%3B%0A%09if (sign %3D%3D%3D 0) %7B%0A%09%09return ZERO%3B%0A%09%7D%0A%09else if (sign < 0) %7B%0A%09%09%2F%2F swap m and n%0A%09%09var t %3D n%3B%0A%09%09n %3D m%3B%0A%09%09m %3D t%3B%0A%09%7D%0A%0A%09%2F%2F a > b%0A%09var a %3D m._d%3B%0A%09var b %3D n._d%3B%0A%09var al %3D a.length%3B%0A%09var bl %3D b.length%3B%0A%09var diff %3D new Array(al)%3B %2F%2F al >%3D bl since a > b%0A%09var borrow %3D 0%3B%0A%09var i%3B%0A%09var digit%3B%0A%0A%09for (i %3D 0%3B i < bl%3B i%2B%2B) %7B%0A%09%09digit %3D a%5Bi%5D - borrow - b%5Bi%5D%3B%0A%09%09if (digit < 0) %7B%0A%09%09%09digit %2B%3D BigInteger_base%3B%0A%09%09%09borrow %3D 1%3B%0A%09%09%7D%0A%09%09else %7B%0A%09%09%09borrow %3D 0%3B%0A%09%09%7D%0A%09%09diff%5Bi%5D %3D digit%3B%0A%09%7D%0A%09for (i %3D bl%3B i < al%3B i%2B%2B) %7B%0A%09%09digit %3D a%5Bi%5D - borrow%3B%0A%09%09if (digit < 0) %7B%0A%09%09%09digit %2B%3D BigInteger_base%3B%0A%09%09%7D%0A%09%09else %7B%0A%09%09%09diff%5Bi%2B%2B%5D %3D digit%3B%0A%09%09%09break%3B%0A%09%09%7D%0A%09%09diff%5Bi%5D %3D digit%3B%0A%09%7D%0A%09for ( %3B i < al%3B i%2B%2B) %7B%0A%09%09diff%5Bi%5D %3D a%5Bi%5D%3B%0A%09%7D%0A%0A%09return new BigInteger(diff%2C sign%2C CONSTRUCT)%3B%0A%7D%3B%0A%0A(function() %7B%0A%09function addOne(n%2C sign) %7B%0A%09%09var a %3D n._d%3B%0A%09%09var sum %3D a.slice()%3B%0A%09%09var carry %3D true%3B%0A%09%09var i %3D 0%3B%0A%0A%09%09while (true) %7B%0A%09%09%09var digit %3D (a%5Bi%5D %7C%7C 0) %2B 1%3B%0A%09%09%09sum%5Bi%5D %3D digit %25 BigInteger_base%3B%0A%09%09%09if (digit <%3D BigInteger_base - 1) %7B%0A%09%09%09%09break%3B%0A%09%09%09%7D%0A%09%09%09%2B%2Bi%3B%0A%09%09%7D%0A%0A%09%09return new BigInteger(sum%2C sign%2C CONSTRUCT)%3B%0A%09%7D%0A%0A%09function subtractOne(n%2C sign) %7B%0A%09%09var a %3D n._d%3B%0A%09%09var sum %3D a.slice()%3B%0A%09%09var borrow %3D true%3B%0A%09%09var i %3D 0%3B%0A%0A%09%09while (true) %7B%0A%09%09%09var digit %3D (a%5Bi%5D %7C%7C 0) - 1%3B%0A%09%09%09if (digit < 0) %7B%0A%09%09%09%09sum%5Bi%5D %3D digit %2B BigInteger_base%3B%0A%09%09%09%7D%0A%09%09%09else %7B%0A%09%09%09%09sum%5Bi%5D %3D digit%3B%0A%09%09%09%09break%3B%0A%09%09%09%7D%0A%09%09%09%2B%2Bi%3B%0A%09%09%7D%0A%0A%09%09return new BigInteger(sum%2C sign%2C CONSTRUCT)%3B%0A%09%7D%0A%0A%09%2F*%0A%09%09Function%3A next%0A%09%09Get the next <BigInteger> (add one).%0A%0A%09%09Returns%3A%0A%0A%09%09%09*this* %2B 1.%0A%0A%09%09See Also%3A%0A%0A%09%09%09<add>%2C <prev>%0A%09*%2F%0A%09BigInteger.prototype.next %3D function() %7B%0A%09%09switch (this._s) %7B%0A%09%09case 0%3A%0A%09%09%09return ONE%3B%0A%09%09case -1%3A%0A%09%09%09return subtractOne(this%2C -1)%3B%0A%09%09%2F%2F case 1%3A%0A%09%09default%3A%0A%09%09%09return addOne(this%2C 1)%3B%0A%09%09%7D%0A%09%7D%3B%0A%0A%09%2F*%0A%09%09Function%3A prev%0A%09%09Get the previous <BigInteger> (subtract one).%0A%0A%09%09Returns%3A%0A%0A%09%09%09*this* - 1.%0A%0A%09%09See Also%3A%0A%0A%09%09%09<next>%2C <subtract>%0A%09*%2F%0A%09BigInteger.prototype.prev %3D function() %7B%0A%09%09switch (this._s) %7B%0A%09%09case 0%3A%0A%09%09%09return M_ONE%3B%0A%09%09case -1%3A%0A%09%09%09return addOne(this%2C -1)%3B%0A%09%09%2F%2F case 1%3A%0A%09%09default%3A%0A%09%09%09return subtractOne(this%2C 1)%3B%0A%09%09%7D%0A%09%7D%3B%0A%7D)()%3B%0A%0A%2F*%0A%09Function%3A compareAbs%0A%09Compare the absolute value of two <BigIntegers>.%0A%0A%09Calling <compareAbs> is faster than calling <abs> twice%2C then <compare>.%0A%0A%09Parameters%3A%0A%0A%09%09n - The number to compare to *this*. Will be converted to a <BigInteger>.%0A%0A%09Returns%3A%0A%0A%09%09-1%2C 0%2C or %2B1 if *%7Cthis%7C* is less than%2C equal to%2C or greater than *%7Cn%7C*.%0A%0A%09See Also%3A%0A%0A%09%09<compare>%2C <abs>%0A*%2F%0ABigInteger.prototype.compareAbs %3D function(n) %7B%0A%09if (this %3D%3D%3D n) %7B%0A%09%09return 0%3B%0A%09%7D%0A%0A%09if (!(n instanceof BigInteger)) %7B%0A%09%09if (!isFinite(n)) %7B%0A%09%09%09return(isNaN(n) %3F n %3A -1)%3B%0A%09%09%7D%0A%09%09n %3D BigInteger(n)%3B%0A%09%7D%0A%0A%09if (this._s %3D%3D%3D 0) %7B%0A%09%09return (n._s !%3D%3D 0) %3F -1 %3A 0%3B%0A%09%7D%0A%09if (n._s %3D%3D%3D 0) %7B%0A%09%09return 1%3B%0A%09%7D%0A%0A%09var l %3D this._d.length%3B%0A%09var nl %3D n._d.length%3B%0A%09if (l < nl) %7B%0A%09%09return -1%3B%0A%09%7D%0A%09else if (l > nl) %7B%0A%09%09return 1%3B%0A%09%7D%0A%0A%09var a %3D this._d%3B%0A%09var b %3D n._d%3B%0A%09for (var i %3D l-1%3B i >%3D 0%3B i--) %7B%0A%09%09if (a%5Bi%5D !%3D%3D b%5Bi%5D) %7B%0A%09%09%09return a%5Bi%5D < b%5Bi%5D %3F -1 %3A 1%3B%0A%09%09%7D%0A%09%7D%0A%0A%09return 0%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A compare%0A%09Compare two <BigIntegers>.%0A%0A%09Parameters%3A%0A%0A%09%09n - The number to compare to *this*. Will be converted to a <BigInteger>.%0A%0A%09Returns%3A%0A%0A%09%09-1%2C 0%2C or %2B1 if *this* is less than%2C equal to%2C or greater than *n*.%0A%0A%09See Also%3A%0A%0A%09%09<compareAbs>%2C <isPositive>%2C <isNegative>%2C <isUnit>%0A*%2F%0ABigInteger.prototype.compare %3D function(n) %7B%0A%09if (this %3D%3D%3D n) %7B%0A%09%09return 0%3B%0A%09%7D%0A%0A%09n %3D BigInteger(n)%3B%0A%0A%09if (this._s %3D%3D%3D 0) %7B%0A%09%09return -n._s%3B%0A%09%7D%0A%0A%09if (this._s %3D%3D%3D n._s) %7B %2F%2F both positive or both negative%0A%09%09var cmp %3D this.compareAbs(n)%3B%0A%09%09return cmp * this._s%3B%0A%09%7D%0A%09else %7B%0A%09%09return this._s%3B%0A%09%7D%0A%7D%3B%0A%0A%2F*%0A%09Function%3A isUnit%0A%09Return true iff *this* is either 1 or -1.%0A%0A%09Returns%3A%0A%0A%09%09true if *this* compares equal to <BigInteger.ONE> or <BigInteger.M_ONE>.%0A%0A%09See Also%3A%0A%0A%09%09<isZero>%2C <isNegative>%2C <isPositive>%2C <compareAbs>%2C <compare>%2C%0A%09%09<BigInteger.ONE>%2C <BigInteger.M_ONE>%0A*%2F%0ABigInteger.prototype.isUnit %3D function() %7B%0A%09return this %3D%3D%3D ONE %7C%7C%0A%09%09this %3D%3D%3D M_ONE %7C%7C%0A%09%09(this._d.length %3D%3D%3D 1 %26%26 this._d%5B0%5D %3D%3D%3D 1)%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A multiply%0A%09Multiply two <BigIntegers>.%0A%0A%09Parameters%3A%0A%0A%09%09n - The number to multiply *this* by. Will be converted to a%0A%09%09<BigInteger>.%0A%0A%09Returns%3A%0A%0A%09%09The numbers multiplied together.%0A%0A%09See Also%3A%0A%0A%09%09<add>%2C <subtract>%2C <quotient>%2C <square>%0A*%2F%0ABigInteger.prototype.multiply %3D function(n) %7B%0A%09%2F%2F TODO%3A Consider adding Karatsuba multiplication for large numbers%0A%09if (this._s %3D%3D%3D 0) %7B%0A%09%09return ZERO%3B%0A%09%7D%0A%0A%09n %3D BigInteger(n)%3B%0A%09if (n._s %3D%3D%3D 0) %7B%0A%09%09return ZERO%3B%0A%09%7D%0A%09if (this.isUnit()) %7B%0A%09%09if (this._s < 0) %7B%0A%09%09%09return n.negate()%3B%0A%09%09%7D%0A%09%09return n%3B%0A%09%7D%0A%09if (n.isUnit()) %7B%0A%09%09if (n._s < 0) %7B%0A%09%09%09return this.negate()%3B%0A%09%09%7D%0A%09%09return this%3B%0A%09%7D%0A%09if (this %3D%3D%3D n) %7B%0A%09%09return this.square()%3B%0A%09%7D%0A%0A%09var r %3D (this._d.length >%3D n._d.length)%3B%0A%09var a %3D (r %3F this %3A n)._d%3B %2F%2F a will be longer than b%0A%09var b %3D (r %3F n %3A this)._d%3B%0A%09var al %3D a.length%3B%0A%09var bl %3D b.length%3B%0A%0A%09var pl %3D al %2B bl%3B%0A%09var partial %3D new Array(pl)%3B%0A%09var i%3B%0A%09for (i %3D 0%3B i < pl%3B i%2B%2B) %7B%0A%09%09partial%5Bi%5D %3D 0%3B%0A%09%7D%0A%0A%09for (i %3D 0%3B i < bl%3B i%2B%2B) %7B%0A%09%09var carry %3D 0%3B%0A%09%09var bi %3D b%5Bi%5D%3B%0A%09%09var jlimit %3D al %2B i%3B%0A%09%09var digit%3B%0A%09%09for (var j %3D i%3B j < jlimit%3B j%2B%2B) %7B%0A%09%09%09digit %3D partial%5Bj%5D %2B bi * a%5Bj - i%5D %2B carry%3B%0A%09%09%09carry %3D (digit %2F BigInteger_base) %7C 0%3B%0A%09%09%09partial%5Bj%5D %3D (digit %25 BigInteger_base) %7C 0%3B%0A%09%09%7D%0A%09%09if (carry) %7B%0A%09%09%09digit %3D partial%5Bj%5D %2B carry%3B%0A%09%09%09carry %3D (digit %2F BigInteger_base) %7C 0%3B%0A%09%09%09partial%5Bj%5D %3D digit %25 BigInteger_base%3B%0A%09%09%7D%0A%09%7D%0A%09return new BigInteger(partial%2C this._s * n._s%2C CONSTRUCT)%3B%0A%7D%3B%0A%0A%2F%2F Multiply a BigInteger by a single-digit native number%0A%2F%2F Assumes that this and n are >%3D 0%0A%2F%2F This is not really intended to be used outside the library itself%0ABigInteger.prototype.multiplySingleDigit %3D function(n) %7B%0A%09if (n %3D%3D%3D 0 %7C%7C this._s %3D%3D%3D 0) %7B%0A%09%09return ZERO%3B%0A%09%7D%0A%09if (n %3D%3D%3D 1) %7B%0A%09%09return this%3B%0A%09%7D%0A%0A%09var digit%3B%0A%09if (this._d.length %3D%3D%3D 1) %7B%0A%09%09digit %3D this._d%5B0%5D * n%3B%0A%09%09if (digit >%3D BigInteger_base) %7B%0A%09%09%09return new BigInteger(%5B(digit %25 BigInteger_base)%7C0%2C%0A%09%09%09%09%09(digit %2F BigInteger_base)%7C0%5D%2C 1%2C CONSTRUCT)%3B%0A%09%09%7D%0A%09%09return new BigInteger(%5Bdigit%5D%2C 1%2C CONSTRUCT)%3B%0A%09%7D%0A%0A%09if (n %3D%3D%3D 2) %7B%0A%09%09return this.add(this)%3B%0A%09%7D%0A%09if (this.isUnit()) %7B%0A%09%09return new BigInteger(%5Bn%5D%2C 1%2C CONSTRUCT)%3B%0A%09%7D%0A%0A%09var a %3D this._d%3B%0A%09var al %3D a.length%3B%0A%0A%09var pl %3D al %2B 1%3B%0A%09var partial %3D new Array(pl)%3B%0A%09for (var i %3D 0%3B i < pl%3B i%2B%2B) %7B%0A%09%09partial%5Bi%5D %3D 0%3B%0A%09%7D%0A%0A%09var carry %3D 0%3B%0A%09for (var j %3D 0%3B j < al%3B j%2B%2B) %7B%0A%09%09digit %3D n * a%5Bj%5D %2B carry%3B%0A%09%09carry %3D (digit %2F BigInteger_base) %7C 0%3B%0A%09%09partial%5Bj%5D %3D (digit %25 BigInteger_base) %7C 0%3B%0A%09%7D%0A%09if (carry) %7B%0A%09%09partial%5Bj%5D %3D carry%3B%0A%09%7D%0A%0A%09return new BigInteger(partial%2C 1%2C CONSTRUCT)%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A square%0A%09Multiply a <BigInteger> by itself.%0A%0A%09This is slightly faster than regular multiplication%2C since it removes the%0A%09duplicated multiplcations.%0A%0A%09Returns%3A%0A%0A%09%09> this.multiply(this)%0A%0A%09See Also%3A%0A%09%09<multiply>%0A*%2F%0ABigInteger.prototype.square %3D function() %7B%0A%09%2F%2F Normally%2C squaring a 10-digit number would take 100 multiplications.%0A%09%2F%2F Of these 10 are unique diagonals%2C of the remaining 90 (100-10)%2C 45 are repeated.%0A%09%2F%2F This procedure saves (N*(N-1))%2F2 multiplications%2C (e.g.%2C 45 of 100 multiplies).%0A%09%2F%2F Based on code by Gary Darby%2C Intellitech Systems Inc.%2C www.DelphiForFun.org%0A%0A%09if (this._s %3D%3D%3D 0) %7B%0A%09%09return ZERO%3B%0A%09%7D%0A%09if (this.isUnit()) %7B%0A%09%09return ONE%3B%0A%09%7D%0A%0A%09var digits %3D this._d%3B%0A%09var length %3D digits.length%3B%0A%09var imult1 %3D new Array(length %2B length %2B 1)%3B%0A%09var product%2C carry%2C k%3B%0A%09var i%3B%0A%0A%09%2F%2F Calculate diagonal%0A%09for (i %3D 0%3B i < length%3B i%2B%2B) %7B%0A%09%09k %3D i * 2%3B%0A%09%09product %3D digits%5Bi%5D * digits%5Bi%5D%3B%0A%09%09carry %3D (product %2F BigInteger_base) %7C 0%3B%0A%09%09imult1%5Bk%5D %3D product %25 BigInteger_base%3B%0A%09%09imult1%5Bk %2B 1%5D %3D carry%3B%0A%09%7D%0A%0A%09%2F%2F Calculate repeating part%0A%09for (i %3D 0%3B i < length%3B i%2B%2B) %7B%0A%09%09carry %3D 0%3B%0A%09%09k %3D i * 2 %2B 1%3B%0A%09%09for (var j %3D i %2B 1%3B j < length%3B j%2B%2B%2C k%2B%2B) %7B%0A%09%09%09product %3D digits%5Bj%5D * digits%5Bi%5D * 2 %2B imult1%5Bk%5D %2B carry%3B%0A%09%09%09carry %3D (product %2F BigInteger_base) %7C 0%3B%0A%09%09%09imult1%5Bk%5D %3D product %25 BigInteger_base%3B%0A%09%09%7D%0A%09%09k %3D length %2B i%3B%0A%09%09var digit %3D carry %2B imult1%5Bk%5D%3B%0A%09%09carry %3D (digit %2F BigInteger_base) %7C 0%3B%0A%09%09imult1%5Bk%5D %3D digit %25 BigInteger_base%3B%0A%09%09imult1%5Bk %2B 1%5D %2B%3D carry%3B%0A%09%7D%0A%0A%09return new BigInteger(imult1%2C 1%2C CONSTRUCT)%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A quotient%0A%09Divide two <BigIntegers> and truncate towards zero.%0A%0A%09<quotient> throws an exception if *n* is zero.%0A%0A%09Parameters%3A%0A%0A%09%09n - The number to divide *this* by. Will be converted to a <BigInteger>.%0A%0A%09Returns%3A%0A%0A%09%09The *this* %2F *n*%2C truncated to an integer.%0A%0A%09See Also%3A%0A%0A%09%09<add>%2C <subtract>%2C <multiply>%2C <divRem>%2C <remainder>%0A*%2F%0ABigInteger.prototype.quotient %3D function(n) %7B%0A%09return this.divRem(n)%5B0%5D%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A divide%0A%09Deprecated synonym for <quotient>.%0A*%2F%0ABigInteger.prototype.divide %3D BigInteger.prototype.quotient%3B%0A%0A%2F*%0A%09Function%3A remainder%0A%09Calculate the remainder of two <BigIntegers>.%0A%0A%09<remainder> throws an exception if *n* is zero.%0A%0A%09Parameters%3A%0A%0A%09%09n - The remainder after *this* is divided *this* by *n*. Will be%0A%09%09    converted to a <BigInteger>.%0A%0A%09Returns%3A%0A%0A%09%09*this* %25 *n*.%0A%0A%09See Also%3A%0A%0A%09%09<divRem>%2C <quotient>%0A*%2F%0ABigInteger.prototype.remainder %3D function(n) %7B%0A%09return this.divRem(n)%5B1%5D%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A divRem%0A%09Calculate the integer quotient and remainder of two <BigIntegers>.%0A%0A%09<divRem> throws an exception if *n* is zero.%0A%0A%09Parameters%3A%0A%0A%09%09n - The number to divide *this* by. Will be converted to a <BigInteger>.%0A%0A%09Returns%3A%0A%0A%09%09A two-element array containing the quotient and the remainder.%0A%0A%09%09> a.divRem(b)%0A%0A%09%09is exactly equivalent to%0A%0A%09%09> %5Ba.quotient(b)%2C a.remainder(b)%5D%0A%0A%09%09except it is faster%2C because they are calculated at the same time.%0A%0A%09See Also%3A%0A%0A%09%09<quotient>%2C <remainder>%0A*%2F%0ABigInteger.prototype.divRem %3D function(n) %7B%0A%09n %3D BigInteger(n)%3B%0A%09if (n._s %3D%3D%3D 0) %7B%0A%09%09throw new Error("Divide by zero")%3B%0A%09%7D%0A%09if (this._s %3D%3D%3D 0) %7B%0A%09%09return %5BZERO%2C ZERO%5D%3B%0A%09%7D%0A%09if (n._d.length %3D%3D%3D 1) %7B%0A%09%09return this.divRemSmall(n._s * n._d%5B0%5D)%3B%0A%09%7D%0A%0A%09%2F%2F Test for easy cases -- %7Cn1%7C <%3D %7Cn2%7C%0A%09switch (this.compareAbs(n)) %7B%0A%09case 0%3A %2F%2F n1 %3D%3D n2%0A%09%09return %5Bthis._s %3D%3D%3D n._s %3F ONE %3A M_ONE%2C ZERO%5D%3B%0A%09case -1%3A %2F%2F %7Cn1%7C < %7Cn2%7C%0A%09%09return %5BZERO%2C this%5D%3B%0A%09%7D%0A%0A%09var sign %3D this._s * n._s%3B%0A%09var a %3D n.abs()%3B%0A%09var b_digits %3D this._d%3B%0A%09var b_index %3D b_digits.length%3B%0A%09var digits %3D n._d.length%3B%0A%09var quot %3D %5B%5D%3B%0A%09var guess%3B%0A%0A%09var part %3D new BigInteger(%5B%5D%2C 0%2C CONSTRUCT)%3B%0A%09part._s %3D 1%3B%0A%0A%09while (b_index) %7B%0A%09%09part._d.unshift(b_digits%5B--b_index%5D)%3B%0A%0A%09%09if (part.compareAbs(n) < 0) %7B%0A%09%09%09quot.push(0)%3B%0A%09%09%09continue%3B%0A%09%09%7D%0A%09%09if (part._s %3D%3D%3D 0) %7B%0A%09%09%09guess %3D 0%3B%0A%09%09%7D%0A%09%09else %7B%0A%09%09%09var xlen %3D part._d.length%2C ylen %3D a._d.length%3B%0A%09%09%09var highx %3D part._d%5Bxlen-1%5D*BigInteger_base %2B part._d%5Bxlen-2%5D%3B%0A%09%09%09var highy %3D a._d%5Bylen-1%5D*BigInteger_base %2B a._d%5Bylen-2%5D%3B%0A%09%09%09if (part._d.length > a._d.length) %7B%0A%09%09%09%09%2F%2F The length of part._d can either match a._d length%2C%0A%09%09%09%09%2F%2F or exceed it by one.%0A%09%09%09%09highx %3D (highx%2B1)*BigInteger_base%3B%0A%09%09%09%7D%0A%09%09%09guess %3D Math.ceil(highx%2Fhighy)%3B%0A%09%09%7D%0A%09%09do %7B%0A%09%09%09var check %3D a.multiplySingleDigit(guess)%3B%0A%09%09%09if (check.compareAbs(part) <%3D 0) %7B%0A%09%09%09%09break%3B%0A%09%09%09%7D%0A%09%09%09guess--%3B%0A%09%09%7D while (guess)%3B%0A%0A%09%09quot.push(guess)%3B%0A%09%09if (!guess) %7B%0A%09%09%09continue%3B%0A%09%09%7D%0A%09%09var diff %3D part.subtract(check)%3B%0A%09%09part._d %3D diff._d.slice()%3B%0A%09%09if (part._d.length %3D%3D%3D 0) %7B%0A%09%09%09part._s %3D 0%3B%0A%09%09%7D%0A%09%7D%0A%0A%09return %5Bnew BigInteger(quot.reverse()%2C sign%2C CONSTRUCT)%2C%0A%09%09   new BigInteger(part._d%2C this._s%2C CONSTRUCT)%5D%3B%0A%7D%3B%0A%0A%2F%2F Throws an exception if n is outside of (-BigInteger.base%2C -1%5D or%0A%2F%2F %5B1%2C BigInteger.base).  It's not necessary to call this%2C since the%0A%2F%2F other division functions will call it if they are able to.%0ABigInteger.prototype.divRemSmall %3D function(n) %7B%0A%09var r%3B%0A%09n %3D %2Bn%3B%0A%09if (n %3D%3D%3D 0) %7B%0A%09%09throw new Error("Divide by zero")%3B%0A%09%7D%0A%0A%09var n_s %3D n < 0 %3F -1 %3A 1%3B%0A%09var sign %3D this._s * n_s%3B%0A%09n %3D Math.abs(n)%3B%0A%0A%09if (n < 1 %7C%7C n >%3D BigInteger_base) %7B%0A%09%09throw new Error("Argument out of range")%3B%0A%09%7D%0A%0A%09if (this._s %3D%3D%3D 0) %7B%0A%09%09return %5BZERO%2C ZERO%5D%3B%0A%09%7D%0A%0A%09if (n %3D%3D%3D 1 %7C%7C n %3D%3D%3D -1) %7B%0A%09%09return %5B(sign %3D%3D%3D 1) %3F this.abs() %3A new BigInteger(this._d%2C sign%2C CONSTRUCT)%2C ZERO%5D%3B%0A%09%7D%0A%0A%09%2F%2F 2 <%3D n < BigInteger_base%0A%0A%09%2F%2F divide a single digit by a single digit%0A%09if (this._d.length %3D%3D%3D 1) %7B%0A%09%09var q %3D new BigInteger(%5B(this._d%5B0%5D %2F n) %7C 0%5D%2C 1%2C CONSTRUCT)%3B%0A%09%09r %3D new BigInteger(%5B(this._d%5B0%5D %25 n) %7C 0%5D%2C 1%2C CONSTRUCT)%3B%0A%09%09if (sign < 0) %7B%0A%09%09%09q %3D q.negate()%3B%0A%09%09%7D%0A%09%09if (this._s < 0) %7B%0A%09%09%09r %3D r.negate()%3B%0A%09%09%7D%0A%09%09return %5Bq%2C r%5D%3B%0A%09%7D%0A%0A%09var digits %3D this._d.slice()%3B%0A%09var quot %3D new Array(digits.length)%3B%0A%09var part %3D 0%3B%0A%09var diff %3D 0%3B%0A%09var i %3D 0%3B%0A%09var guess%3B%0A%0A%09while (digits.length) %7B%0A%09%09part %3D part * BigInteger_base %2B digits%5Bdigits.length - 1%5D%3B%0A%09%09if (part < n) %7B%0A%09%09%09quot%5Bi%2B%2B%5D %3D 0%3B%0A%09%09%09digits.pop()%3B%0A%09%09%09diff %3D BigInteger_base * diff %2B part%3B%0A%09%09%09continue%3B%0A%09%09%7D%0A%09%09if (part %3D%3D%3D 0) %7B%0A%09%09%09guess %3D 0%3B%0A%09%09%7D%0A%09%09else %7B%0A%09%09%09guess %3D (part %2F n) %7C 0%3B%0A%09%09%7D%0A%0A%09%09var check %3D n * guess%3B%0A%09%09diff %3D part - check%3B%0A%09%09quot%5Bi%2B%2B%5D %3D guess%3B%0A%09%09if (!guess) %7B%0A%09%09%09digits.pop()%3B%0A%09%09%09continue%3B%0A%09%09%7D%0A%0A%09%09digits.pop()%3B%0A%09%09part %3D diff%3B%0A%09%7D%0A%0A%09r %3D new BigInteger(%5Bdiff%5D%2C 1%2C CONSTRUCT)%3B%0A%09if (this._s < 0) %7B%0A%09%09r %3D r.negate()%3B%0A%09%7D%0A%09return %5Bnew BigInteger(quot.reverse()%2C sign%2C CONSTRUCT)%2C r%5D%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A isEven%0A%09Return true iff *this* is divisible by two.%0A%0A%09Note that <BigInteger.ZERO> is even.%0A%0A%09Returns%3A%0A%0A%09%09true if *this* is even%2C false otherwise.%0A%0A%09See Also%3A%0A%0A%09%09<isOdd>%0A*%2F%0ABigInteger.prototype.isEven %3D function() %7B%0A%09var digits %3D this._d%3B%0A%09return this._s %3D%3D%3D 0 %7C%7C digits.length %3D%3D%3D 0 %7C%7C (digits%5B0%5D %25 2) %3D%3D%3D 0%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A isOdd%0A%09Return true iff *this* is not divisible by two.%0A%0A%09Returns%3A%0A%0A%09%09true if *this* is odd%2C false otherwise.%0A%0A%09See Also%3A%0A%0A%09%09<isEven>%0A*%2F%0ABigInteger.prototype.isOdd %3D function() %7B%0A%09return !this.isEven()%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A sign%0A%09Get the sign of a <BigInteger>.%0A%0A%09Returns%3A%0A%0A%09%09* -1 if *this* < 0%0A%09%09* 0 if *this* %3D%3D 0%0A%09%09* %2B1 if *this* > 0%0A%0A%09See Also%3A%0A%0A%09%09<isZero>%2C <isPositive>%2C <isNegative>%2C <compare>%2C <BigInteger.ZERO>%0A*%2F%0ABigInteger.prototype.sign %3D function() %7B%0A%09return this._s%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A isPositive%0A%09Return true iff *this* > 0.%0A%0A%09Returns%3A%0A%0A%09%09true if *this*.compare(<BigInteger.ZERO>) %3D%3D 1.%0A%0A%09See Also%3A%0A%0A%09%09<sign>%2C <isZero>%2C <isNegative>%2C <isUnit>%2C <compare>%2C <BigInteger.ZERO>%0A*%2F%0ABigInteger.prototype.isPositive %3D function() %7B%0A%09return this._s > 0%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A isNegative%0A%09Return true iff *this* < 0.%0A%0A%09Returns%3A%0A%0A%09%09true if *this*.compare(<BigInteger.ZERO>) %3D%3D -1.%0A%0A%09See Also%3A%0A%0A%09%09<sign>%2C <isPositive>%2C <isZero>%2C <isUnit>%2C <compare>%2C <BigInteger.ZERO>%0A*%2F%0ABigInteger.prototype.isNegative %3D function() %7B%0A%09return this._s < 0%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A isZero%0A%09Return true iff *this* %3D%3D 0.%0A%0A%09Returns%3A%0A%0A%09%09true if *this*.compare(<BigInteger.ZERO>) %3D%3D 0.%0A%0A%09See Also%3A%0A%0A%09%09<sign>%2C <isPositive>%2C <isNegative>%2C <isUnit>%2C <BigInteger.ZERO>%0A*%2F%0ABigInteger.prototype.isZero %3D function() %7B%0A%09return this._s %3D%3D%3D 0%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A exp10%0A%09Multiply a <BigInteger> by a power of 10.%0A%0A%09This is equivalent to%2C but faster than%0A%0A%09> if (n >%3D 0) %7B%0A%09>     return this.multiply(BigInteger("1e" %2B n))%3B%0A%09> %7D%0A%09> else %7B %2F%2F n <%3D 0%0A%09>     return this.quotient(BigInteger("1e" %2B -n))%3B%0A%09> %7D%0A%0A%09Parameters%3A%0A%0A%09%09n - The power of 10 to multiply *this* by. *n* is converted to a%0A%09%09javascipt number and must be no greater than <BigInteger.MAX_EXP>%0A%09%09(0x7FFFFFFF)%2C or an exception will be thrown.%0A%0A%09Returns%3A%0A%0A%09%09*this* * (10 ** *n*)%2C truncated to an integer if necessary.%0A%0A%09See Also%3A%0A%0A%09%09<pow>%2C <multiply>%0A*%2F%0ABigInteger.prototype.exp10 %3D function(n) %7B%0A%09n %3D %2Bn%3B%0A%09if (n %3D%3D%3D 0) %7B%0A%09%09return this%3B%0A%09%7D%0A%09if (Math.abs(n) > Number(MAX_EXP)) %7B%0A%09%09throw new Error("exponent too large in BigInteger.exp10")%3B%0A%09%7D%0A%09if (n > 0) %7B%0A%09%09var k %3D new BigInteger(this._d.slice()%2C this._s%2C CONSTRUCT)%3B%0A%0A%09%09for (%3B n >%3D BigInteger_base_log10%3B n -%3D BigInteger_base_log10) %7B%0A%09%09%09k._d.unshift(0)%3B%0A%09%09%7D%0A%09%09if (n %3D%3D 0)%0A%09%09%09return k%3B%0A%09%09k._s %3D 1%3B%0A%09%09k %3D k.multiplySingleDigit(Math.pow(10%2C n))%3B%0A%09%09return (this._s < 0 %3F k.negate() %3A k)%3B%0A%09%7D else if (-n >%3D this._d.length*BigInteger_base_log10) %7B%0A%09%09return ZERO%3B%0A%09%7D else %7B%0A%09%09var k %3D new BigInteger(this._d.slice()%2C this._s%2C CONSTRUCT)%3B%0A%0A%09%09for (n %3D -n%3B n >%3D BigInteger_base_log10%3B n -%3D BigInteger_base_log10) %7B%0A%09%09%09k._d.shift()%3B%0A%09%09%7D%0A%09%09return (n %3D%3D 0) %3F k %3A k.divRemSmall(Math.pow(10%2C n))%5B0%5D%3B%0A%09%7D%0A%7D%3B%0A%0A%2F*%0A%09Function%3A pow%0A%09Raise a <BigInteger> to a power.%0A%0A%09In this implementation%2C 0**0 is 1.%0A%0A%09Parameters%3A%0A%0A%09%09n - The exponent to raise *this* by. *n* must be no greater than%0A%09%09<BigInteger.MAX_EXP> (0x7FFFFFFF)%2C or an exception will be thrown.%0A%0A%09Returns%3A%0A%0A%09%09*this* raised to the *nth* power.%0A%0A%09See Also%3A%0A%0A%09%09<modPow>%0A*%2F%0ABigInteger.prototype.pow %3D function(n) %7B%0A%09if (this.isUnit()) %7B%0A%09%09if (this._s > 0) %7B%0A%09%09%09return this%3B%0A%09%09%7D%0A%09%09else %7B%0A%09%09%09return BigInteger(n).isOdd() %3F this %3A this.negate()%3B%0A%09%09%7D%0A%09%7D%0A%0A%09n %3D BigInteger(n)%3B%0A%09if (n._s %3D%3D%3D 0) %7B%0A%09%09return ONE%3B%0A%09%7D%0A%09else if (n._s < 0) %7B%0A%09%09if (this._s %3D%3D%3D 0) %7B%0A%09%09%09throw new Error("Divide by zero")%3B%0A%09%09%7D%0A%09%09else %7B%0A%09%09%09return ZERO%3B%0A%09%09%7D%0A%09%7D%0A%09if (this._s %3D%3D%3D 0) %7B%0A%09%09return ZERO%3B%0A%09%7D%0A%09if (n.isUnit()) %7B%0A%09%09return this%3B%0A%09%7D%0A%0A%09if (n.compareAbs(MAX_EXP) > 0) %7B%0A%09%09throw new Error("exponent too large in BigInteger.pow")%3B%0A%09%7D%0A%09var x %3D this%3B%0A%09var aux %3D ONE%3B%0A%09var two %3D BigInteger.small%5B2%5D%3B%0A%0A%09while (n.isPositive()) %7B%0A%09%09if (n.isOdd()) %7B%0A%09%09%09aux %3D aux.multiply(x)%3B%0A%09%09%09if (n.isUnit()) %7B%0A%09%09%09%09return aux%3B%0A%09%09%09%7D%0A%09%09%7D%0A%09%09x %3D x.square()%3B%0A%09%09n %3D n.quotient(two)%3B%0A%09%7D%0A%0A%09return aux%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A modPow%0A%09Raise a <BigInteger> to a power (mod m).%0A%0A%09Because it is reduced by a modulus%2C <modPow> is not limited by%0A%09<BigInteger.MAX_EXP> like <pow>.%0A%0A%09Parameters%3A%0A%0A%09%09exponent - The exponent to raise *this* by. Must be positive.%0A%09%09modulus - The modulus.%0A%0A%09Returns%3A%0A%0A%09%09*this* %5E *exponent* (mod *modulus*).%0A%0A%09See Also%3A%0A%0A%09%09<pow>%2C <mod>%0A*%2F%0ABigInteger.prototype.modPow %3D function(exponent%2C modulus) %7B%0A%09var result %3D ONE%3B%0A%09var base %3D this%3B%0A%0A%09while (exponent.isPositive()) %7B%0A%09%09if (exponent.isOdd()) %7B%0A%09%09%09result %3D result.multiply(base).remainder(modulus)%3B%0A%09%09%7D%0A%0A%09%09exponent %3D exponent.quotient(BigInteger.small%5B2%5D)%3B%0A%09%09if (exponent.isPositive()) %7B%0A%09%09%09base %3D base.square().remainder(modulus)%3B%0A%09%09%7D%0A%09%7D%0A%0A%09return result%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A log%0A%09Get the natural logarithm of a <BigInteger> as a native JavaScript number.%0A%0A%09This is equivalent to%0A%0A%09> Math.log(this.toJSValue())%0A%0A%09but handles values outside of the native number range.%0A%0A%09Returns%3A%0A%0A%09%09log( *this* )%0A%0A%09See Also%3A%0A%0A%09%09<toJSValue>%0A*%2F%0ABigInteger.prototype.log %3D function() %7B%0A%09switch (this._s) %7B%0A%09case 0%3A%09 return -Infinity%3B%0A%09case -1%3A return NaN%3B%0A%09default%3A %2F%2F Fall through.%0A%09%7D%0A%0A%09var l %3D this._d.length%3B%0A%0A%09if (l*BigInteger_base_log10 < 30) %7B%0A%09%09return Math.log(this.valueOf())%3B%0A%09%7D%0A%0A%09var N %3D Math.ceil(30%2FBigInteger_base_log10)%3B%0A%09var firstNdigits %3D this._d.slice(l - N)%3B%0A%09return Math.log((new BigInteger(firstNdigits%2C 1%2C CONSTRUCT)).valueOf()) %2B (l - N) * Math.log(BigInteger_base)%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A valueOf%0A%09Convert a <BigInteger> to a native JavaScript integer.%0A%0A%09This is called automatically by JavaScipt to convert a <BigInteger> to a%0A%09native value.%0A%0A%09Returns%3A%0A%0A%09%09> parseInt(this.toString()%2C 10)%0A%0A%09See Also%3A%0A%0A%09%09<toString>%2C <toJSValue>%0A*%2F%0ABigInteger.prototype.valueOf %3D function() %7B%0A%09return parseInt(this.toString()%2C 10)%3B%0A%7D%3B%0A%0A%2F*%0A%09Function%3A toJSValue%0A%09Convert a <BigInteger> to a native JavaScript integer.%0A%0A%09This is the same as valueOf%2C but more explicitly named.%0A%0A%09Returns%3A%0A%0A%09%09> parseInt(this.toString()%2C 10)%0A%0A%09See Also%3A%0A%0A%09%09<toString>%2C <valueOf>%0A*%2F%0ABigInteger.prototype.toJSValue %3D function() %7B%0A%09return parseInt(this.toString()%2C 10)%3B%0A%7D%3B%0A%0Avar MAX_EXP %3D BigInteger(0x7FFFFFFF)%3B%0A%2F%2F Constant%3A MAX_EXP%0A%2F%2F The largest exponent allowed in <pow> and <exp10> (0x7FFFFFFF or 2147483647).%0ABigInteger.MAX_EXP %3D MAX_EXP%3B%0A%0A(function() %7B%0A%09function makeUnary(fn) %7B%0A%09%09return function(a) %7B%0A%09%09%09return fn.call(BigInteger(a))%3B%0A%09%09%7D%3B%0A%09%7D%0A%0A%09function makeBinary(fn) %7B%0A%09%09return function(a%2C b) %7B%0A%09%09%09return fn.call(BigInteger(a)%2C BigInteger(b))%3B%0A%09%09%7D%3B%0A%09%7D%0A%0A%09function makeTrinary(fn) %7B%0A%09%09return function(a%2C b%2C c) %7B%0A%09%09%09return fn.call(BigInteger(a)%2C BigInteger(b)%2C BigInteger(c))%3B%0A%09%09%7D%3B%0A%09%7D%0A%0A%09(function() %7B%0A%09%09var i%2C fn%3B%0A%09%09var unary %3D "toJSValue%2CisEven%2CisOdd%2Csign%2CisZero%2CisNegative%2Cabs%2CisUnit%2Csquare%2Cnegate%2CisPositive%2CtoString%2Cnext%2Cprev%2Clog".split("%2C")%3B%0A%09%09var binary %3D "compare%2Cremainder%2CdivRem%2Csubtract%2Cadd%2Cquotient%2Cdivide%2Cmultiply%2Cpow%2CcompareAbs".split("%2C")%3B%0A%09%09var trinary %3D %5B"modPow"%5D%3B%0A%0A%09%09for (i %3D 0%3B i < unary.length%3B i%2B%2B) %7B%0A%09%09%09fn %3D unary%5Bi%5D%3B%0A%09%09%09BigInteger%5Bfn%5D %3D makeUnary(BigInteger.prototype%5Bfn%5D)%3B%0A%09%09%7D%0A%0A%09%09for (i %3D 0%3B i < binary.length%3B i%2B%2B) %7B%0A%09%09%09fn %3D binary%5Bi%5D%3B%0A%09%09%09BigInteger%5Bfn%5D %3D makeBinary(BigInteger.prototype%5Bfn%5D)%3B%0A%09%09%7D%0A%0A%09%09for (i %3D 0%3B i < trinary.length%3B i%2B%2B) %7B%0A%09%09%09fn %3D trinary%5Bi%5D%3B%0A%09%09%09BigInteger%5Bfn%5D %3D makeTrinary(BigInteger.prototype%5Bfn%5D)%3B%0A%09%09%7D%0A%0A%09%09BigInteger.exp10 %3D function(x%2C n) %7B%0A%09%09%09return BigInteger(x).exp10(n)%3B%0A%09%09%7D%3B%0A%09%7D)()%3B%0A%7D)()%3B%0A%0Aexports.BigInteger %3D BigInteger%3B%0A%7D)(biginteger)%3B%0A%0Avar assert %3D function () %7B return assert.ok.apply(this%2C arguments)%3B %7D%3B%0A(function (exports) %7B%0A  "use strict"%3B%0A%0A%2F%2F http%3A%2F%2Fwiki.commonjs.org%2Fwiki%2FUnit_Testing%2F1.0%0A%2F%2F%0A%2F%2F THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!%0A%2F%2F%0A%2F%2F Originally from narwhal.js (http%3A%2F%2Fnarwhaljs.org)%0A%2F%2F Copyright (c) 2009 Thomas Robinson <280north.com>%0A%2F%2F%0A%2F%2F Permission is hereby granted%2C free of charge%2C to any person obtaining a copy%0A%2F%2F of this software and associated documentation files (the 'Software')%2C to%0A%2F%2F deal in the Software without restriction%2C including without limitation the%0A%2F%2F rights to use%2C copy%2C modify%2C merge%2C publish%2C distribute%2C sublicense%2C and%2For%0A%2F%2F sell copies of the Software%2C and to permit persons to whom the Software is%0A%2F%2F furnished to do so%2C subject to the following conditions%3A%0A%2F%2F%0A%2F%2F The above copyright notice and this permission notice shall be included in%0A%2F%2F all copies or substantial portions of the Software.%0A%2F%2F%0A%2F%2F THE SOFTWARE IS PROVIDED 'AS IS'%2C WITHOUT WARRANTY OF ANY KIND%2C EXPRESS OR%0A%2F%2F IMPLIED%2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY%2C%0A%2F%2F FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE%0A%2F%2F AUTHORS BE LIABLE FOR ANY CLAIM%2C DAMAGES OR OTHER LIABILITY%2C WHETHER IN AN%0A%2F%2F ACTION OF CONTRACT%2C TORT OR OTHERWISE%2C ARISING FROM%2C OUT OF OR IN CONNECTION%0A%2F%2F WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.%0A%0Avar pSlice %3D Array.prototype.slice%3B%0A%0A%2F%2F 1. The assert module provides functions that throw%0A%2F%2F AssertionError's when particular conditions are not met. The%0A%2F%2F assert module must conform to the following interface.%0A%0Avar assert %3D exports%3B%0A%0A%2F%2F 2. The AssertionError is defined in assert.%0A%2F%2F new assert.AssertionError(%7B message%3A message%2C%0A%2F%2F                             actual%3A actual%2C%0A%2F%2F                             expected%3A expected %7D)%0A%0Aassert.AssertionError %3D function AssertionError(options) %7B%0A  this.name %3D 'AssertionError'%3B%0A  this.message %3D options.message%3B%0A  this.actual %3D options.actual%3B%0A  this.expected %3D options.expected%3B%0A  this.operator %3D options.operator%3B%0A  var stackStartFunction %3D options.stackStartFunction %7C%7C fail%3B%0A%0A  if (Error.captureStackTrace) %7B%0A    Error.captureStackTrace(this%2C stackStartFunction)%3B%0A  %7D%0A%7D%3B%0Aassert.AssertionError.prototype %3D Object.create(Error.prototype)%3B%0A%0Aassert.AssertionError.prototype.toString %3D function() %7B%0A  if (this.message) %7B%0A    return %5Bthis.name %2B '%3A'%2C this.message%5D.join(' ')%3B%0A  %7D else %7B%0A    return %5Bthis.name %2B '%3A'%2C%0A            JSON.stringify(this.expected)%2C%0A            this.operator%2C%0A            JSON.stringify(this.actual)%5D.join(' ')%3B%0A  %7D%0A%7D%3B%0A%0A%2F%2F assert.AssertionError instanceof Error%0A%0Aassert.AssertionError.__proto__ %3D Error.prototype%3B%0A%0A%2F%2F At present only the three keys mentioned above are used and%0A%2F%2F understood by the spec. Implementations or sub modules can pass%0A%2F%2F other keys to the AssertionError's constructor - they will be%0A%2F%2F ignored.%0A%0A%2F%2F 3. All of the following functions must throw an AssertionError%0A%2F%2F when a corresponding condition is not met%2C with a message that%0A%2F%2F may be undefined if not provided.  All assertion methods provide%0A%2F%2F both the actual and expected values to the assertion error for%0A%2F%2F display purposes.%0A%0Afunction fail(actual%2C expected%2C message%2C operator%2C stackStartFunction) %7B%0A  throw new assert.AssertionError(%7B%0A    message%3A message%2C%0A    actual%3A actual%2C%0A    expected%3A expected%2C%0A    operator%3A operator%2C%0A    stackStartFunction%3A stackStartFunction%0A  %7D)%3B%0A%7D%0A%0A%2F%2F EXTENSION! allows for well behaved errors defined elsewhere.%0Aassert.fail %3D fail%3B%0A%0A%2F%2F 4. Pure assertion tests whether a value is truthy%2C as determined%0A%2F%2F by !!guard.%0A%2F%2F assert.ok(guard%2C message_opt)%3B%0A%2F%2F This statement is equivalent to assert.equal(true%2C guard%2C%0A%2F%2F message_opt)%3B. To test strictly for the value true%2C use%0A%2F%2F assert.strictEqual(true%2C guard%2C message_opt)%3B.%0A%0Aassert.ok %3D function ok(value%2C message) %7B%0A  if (!!!value) fail(value%2C true%2C message%2C '%3D%3D'%2C assert.ok)%3B%0A%7D%3B%0A%0A%2F%2F 5. The equality assertion tests shallow%2C coercive equality with%0A%2F%2F %3D%3D.%0A%2F%2F assert.equal(actual%2C expected%2C message_opt)%3B%0A%0Aassert.equal %3D function equal(actual%2C expected%2C message) %7B%0A  if (actual !%3D expected) fail(actual%2C expected%2C message%2C '%3D%3D'%2C assert.equal)%3B%0A%7D%3B%0A%0A%2F%2F 6. The non-equality assertion tests for whether two objects are not equal%0A%2F%2F with !%3D assert.notEqual(actual%2C expected%2C message_opt)%3B%0A%0Aassert.notEqual %3D function notEqual(actual%2C expected%2C message) %7B%0A  if (actual %3D%3D expected) %7B%0A    fail(actual%2C expected%2C message%2C '!%3D'%2C assert.notEqual)%3B%0A  %7D%0A%7D%3B%0A%0A%2F%2F 7. The equivalence assertion tests a deep equality relation.%0A%2F%2F assert.deepEqual(actual%2C expected%2C message_opt)%3B%0A%0Aassert.deepEqual %3D function deepEqual(actual%2C expected%2C message) %7B%0A  if (!_deepEqual(actual%2C expected)) %7B%0A    fail(actual%2C expected%2C message%2C 'deepEqual'%2C assert.deepEqual)%3B%0A  %7D%0A%7D%3B%0A%0Afunction _deepEqual(actual%2C expected) %7B%0A  %2F%2F 7.1. All identical values are equivalent%2C as determined by %3D%3D%3D.%0A  if (actual %3D%3D%3D expected) %7B%0A    return true%3B%0A%0A  %2F%2F 7.2. If the expected value is a Date object%2C the actual value is%0A  %2F%2F equivalent if it is also a Date object that refers to the same time.%0A  %7D else if (actual instanceof Date %26%26 expected instanceof Date) %7B%0A    return actual.getTime() %3D%3D%3D expected.getTime()%3B%0A%0A  %2F%2F 7.3. Other pairs that do not both pass typeof value %3D%3D 'object'%2C%0A  %2F%2F equivalence is determined by %3D%3D.%0A  %7D else if (typeof actual !%3D 'object' %26%26 typeof expected !%3D 'object') %7B%0A    return actual %3D%3D expected%3B%0A%0A  %2F%2F 7.4. For all other Object pairs%2C including Array objects%2C equivalence is%0A  %2F%2F determined by having the same number of owned properties (as verified%0A  %2F%2F with Object.prototype.hasOwnProperty.call)%2C the same set of keys%0A  %2F%2F (although not necessarily the same order)%2C equivalent values for every%0A  %2F%2F corresponding key%2C and an identical 'prototype' property. Note%3A this%0A  %2F%2F accounts for both named and indexed properties on Arrays.%0A  %7D else %7B%0A    return objEquiv(actual%2C expected)%3B%0A  %7D%0A%7D%0A%0Afunction isUndefinedOrNull(value) %7B%0A  return value %3D%3D%3D null %7C%7C value %3D%3D%3D undefined%3B%0A%7D%0A%0Afunction isArguments(object) %7B%0A  return Object.prototype.toString.call(object) %3D%3D '%5Bobject Arguments%5D'%3B%0A%7D%0A%0Afunction objEquiv(a%2C b) %7B%0A  if (isUndefinedOrNull(a) %7C%7C isUndefinedOrNull(b))%0A    return false%3B%0A  %2F%2F an identical 'prototype' property.%0A  if (a.prototype !%3D%3D b.prototype) return false%3B%0A  %2F%2F~~~I've managed to break Object.keys through screwy arguments passing.%0A  %2F%2F   Converting to array solves the problem.%0A  if (isArguments(a)) %7B%0A    if (!isArguments(b)) %7B%0A      return false%3B%0A    %7D%0A    a %3D pSlice.call(a)%3B%0A    b %3D pSlice.call(b)%3B%0A    return _deepEqual(a%2C b)%3B%0A  %7D%0A  try %7B%0A    var ka %3D Object.keys(a)%2C%0A        kb %3D Object.keys(b)%2C%0A        key%2C i%3B%0A  %7D catch (e) %7B%2F%2Fhappens when one is a string literal and the other isn't%0A    return false%3B%0A  %7D%0A  %2F%2F having the same number of owned properties (keys incorporates%0A  %2F%2F hasOwnProperty)%0A  if (ka.length !%3D kb.length)%0A    return false%3B%0A  %2F%2Fthe same set of keys (although not necessarily the same order)%2C%0A  ka.sort()%3B%0A  kb.sort()%3B%0A  %2F%2F~~~cheap key test%0A  for (i %3D ka.length - 1%3B i >%3D 0%3B i--) %7B%0A    if (ka%5Bi%5D !%3D kb%5Bi%5D)%0A      return false%3B%0A  %7D%0A  %2F%2Fequivalent values for every corresponding key%2C and%0A  %2F%2F~~~possibly expensive deep test%0A  for (i %3D ka.length - 1%3B i >%3D 0%3B i--) %7B%0A    key %3D ka%5Bi%5D%3B%0A    if (!_deepEqual(a%5Bkey%5D%2C b%5Bkey%5D)) return false%3B%0A  %7D%0A  return true%3B%0A%7D%0A%0A%2F%2F 8. The non-equivalence assertion tests for any deep inequality.%0A%2F%2F assert.notDeepEqual(actual%2C expected%2C message_opt)%3B%0A%0Aassert.notDeepEqual %3D function notDeepEqual(actual%2C expected%2C message) %7B%0A  if (_deepEqual(actual%2C expected)) %7B%0A    fail(actual%2C expected%2C message%2C 'notDeepEqual'%2C assert.notDeepEqual)%3B%0A  %7D%0A%7D%3B%0A%0A%2F%2F 9. The strict equality assertion tests strict equality%2C as determined by %3D%3D%3D.%0A%2F%2F assert.strictEqual(actual%2C expected%2C message_opt)%3B%0A%0Aassert.strictEqual %3D function strictEqual(actual%2C expected%2C message) %7B%0A  if (actual !%3D%3D expected) %7B%0A    fail(actual%2C expected%2C message%2C '%3D%3D%3D'%2C assert.strictEqual)%3B%0A  %7D%0A%7D%3B%0A%0A%2F%2F 10. The strict non-equality assertion tests for strict inequality%2C as%0A%2F%2F determined by !%3D%3D.  assert.notStrictEqual(actual%2C expected%2C message_opt)%3B%0A%0Aassert.notStrictEqual %3D function notStrictEqual(actual%2C expected%2C message) %7B%0A  if (actual %3D%3D%3D expected) %7B%0A    fail(actual%2C expected%2C message%2C '!%3D%3D'%2C assert.notStrictEqual)%3B%0A  %7D%0A%7D%3B%0A%0Afunction expectedException(actual%2C expected) %7B%0A  if (!actual %7C%7C !expected) %7B%0A    return false%3B%0A  %7D%0A%0A  if (expected instanceof RegExp) %7B%0A    return expected.test(actual)%3B%0A  %7D else if (actual instanceof expected) %7B%0A    return true%3B%0A  %7D else if (expected.call(%7B%7D%2C actual) %3D%3D%3D true) %7B%0A    return true%3B%0A  %7D%0A%0A  return false%3B%0A%7D%0A%0Afunction _throws(shouldThrow%2C block%2C expected%2C message) %7B%0A  var actual%3B%0A%0A  if (typeof expected %3D%3D%3D 'string') %7B%0A    message %3D expected%3B%0A    expected %3D null%3B%0A  %7D%0A%0A  try %7B%0A    block()%3B%0A  %7D catch (e) %7B%0A    actual %3D e%3B%0A  %7D%0A%0A  message %3D (expected %26%26 expected.name %3F ' (' %2B expected.name %2B ').' %3A '.') %2B%0A            (message %3F ' ' %2B message %3A '.')%3B%0A%0A  if (shouldThrow %26%26 !actual) %7B%0A    fail('Missing expected exception' %2B message)%3B%0A  %7D%0A%0A  if (!shouldThrow %26%26 expectedException(actual%2C expected)) %7B%0A    fail('Got unwanted exception' %2B message)%3B%0A  %7D%0A%0A  if ((shouldThrow %26%26 actual %26%26 expected %26%26%0A      !expectedException(actual%2C expected)) %7C%7C (!shouldThrow %26%26 actual)) %7B%0A    throw actual%3B%0A  %7D%0A%7D%0A%0A%2F%2F 11. Expected to throw an error%3A%0A%2F%2F assert.throws(block%2C Error_opt%2C message_opt)%3B%0A%0Aassert.throws %3D function(block%2C %2F*optional*%2Ferror%2C %2F*optional*%2Fmessage) %7B%0A  _throws.apply(this%2C %5Btrue%5D.concat(pSlice.call(arguments)))%3B%0A%7D%3B%0A%0A%2F%2F EXTENSION! This is annoying to write outside this module.%0Aassert.doesNotThrow %3D function(block%2C %2F*optional*%2Ferror%2C %2F*optional*%2Fmessage) %7B%0A  _throws.apply(this%2C %5Bfalse%5D.concat(pSlice.call(arguments)))%3B%0A%7D%3B%0A%0Aassert.ifError %3D function(err) %7B if (err) %7Bthrow err%3B%7D%7D%3B%0A%0A%7D(assert))%3B%0A%0Aconst math %3D %7B%0A    add%3A function (a%2Cb) %7B%0A        return a%2Bb%3B%0A    %7D%2C%0A    min %3A function (a%2Cb) %7B%0A        return a-b%3B%0A    %7D%2C%0A    mul %3A function (a%2Cb) %7B%0A        return a*b%3B%0A    %7D%2C%0A    div %3A function (a%2Cb) %7B%0A        return a%2Fb%3B%0A    %7D%2C%0A    pwr %3A function (a%2Cb) %7B%0A        return a%5Eb%3B%0A    %7D%2C%0A    pct %3A function (a%2Cb) %7B%0A        return a%25b%3B%0A    %7D%2C%0A    sin %3A function (a%2Ct) %7B%0A        if (sin%3D%3D0) %7B%0A            return Math.sin(a)%3B%0A        %7D else %7B%0A            return Math.asin(a)%3B%0A        %7D%3B%0A    %7D%2C%0A    tan %3A function (a%2Ct) %7B%0A        if (sin%3D%3D0) %7B%0A            return Math.tan(a)%3B%0A        %7D else %7B%0A            return Math.atan(a)%3B%0A        %7D%3B%0A    %7D%2C%0A    cos %3A function (a%2Ct) %7B%0A        if (sin%3D%3D0) %7B%0A            return Math.cos(a)%3B%0A        %7D else %7B%0A            return Math.acos(a)%3B%0A        %7D%3B%0A    %7D%0A%7D%3B%0A%2F%2F %23 calculator-parser.js%0A%2F%2F%0A%2F%2F a simple calculator language%0A%0A%2F%2F This program parses a very simple language that just does a little basic%0A%2F%2F arithmetic. Here are some simple examples of the sort of thing you can%0A%2F%2F write in the calculator language%3A%0A%2F%2F%0A%2F%2F   * %602 %2B 2%60%0A%2F%2F   * %601 * 2 %2B 3 * 4 %2B 5 %2F 6%60%0A%2F%2F   * %603 %2B 1%2F(7 %2B 1%2F(15 %2B 1%2F(1 %2B 1%2F(292 %2B 1%2F(1 %2B 1%2F(1 %2B 1%2F1))))))%60%0A%2F%2F   * %601 %2F ((z %2B 1) * (z - 1))%60%0A%2F%2F%0A%2F%2F If youd like to try it out%2C open %5Bcalculator.html%5D(..%2Fcalculator.html).%0A%0A%0A%2F%2F %23%23 Part One  Breaking code down into tokens%0A%0A%2F%2F This function%2C %60tokenize(code)%60%2C takes a string %60code%60 and splits it into%0A%2F%2F *tokens*%2C the numbers%2C words%2C and symbols that make up our little calculator%0A%2F%2F mini-language.%0Afunction tokenize(code) %7B%0A    var results %3D %5B%5D%3B%0A    var tokenRegExp %3D %2F%5Cs*(%5BA-Za-z%5D%2B%7C%5B0-9%5D%2B%7C%5CS)%5Cs*%2Fg%3B%0A%0A    var m%3B%0A    while ((m %3D tokenRegExp.exec(code)) !%3D%3D null)%0A        results.push(m%5B1%5D)%3B%0A    return results%3B%0A%7D%0A%0A%2F%2F Lets test as we go!%0Aassert.deepEqual(tokenize("123%5Cn")%2C %5B"123"%5D)%3B%0Aassert.deepEqual(tokenize("2%2B2")%2C %5B"2"%2C "%2B"%2C "2"%5D)%3B%0Aassert.deepEqual(tokenize("%2B-*%2F")%2C %5B"%2B"%2C "-"%2C "*"%2C "%2F"%5D)%3B%0Aassert.deepEqual(tokenize("   1   * 24 %2B%5Cn%5Cn  pi")%2C %5B"1"%2C "*"%2C "24"%2C "%2B"%2C "pi"%5D)%3B%0Aassert.deepEqual(tokenize("()")%2C %5B"("%2C ")"%5D)%3B%0Aassert.deepEqual(tokenize("    ")%2C %5B%5D)%3B%0A%0A%0A%0A%2F%2F Here are a few helper functions for working with tokens. To keep things%0A%2F%2F simple%2C a number is any sequence of digits.%0Afunction isNumber(token) %7B%0A    return token !%3D%3D undefined %26%26 token.match(%2F%5E%5B0-9%5D%2B%24%2F) !%3D%3D null%3B%0A%7D%0A%0A%2F%2F And a *name*%2C or identifier%2C is any sequence of letters.%0Afunction isName(token) %7B%0A    return token !%3D%3D undefined %26%26 token.match(%2F%5E%5BA-Za-z%5D%2B%24%2F) !%3D%3D null%3B%0A%7D%0A%0A%2F%2F Tests.%0Aassert(isNumber("123"))%3B%0Aassert(!isNumber("x"))%3B%0Aassert(!isNumber("-"))%3B%0Aassert(isName("xyz"))%3B%0Aassert(!isName("%2B"))%3B%0A%0A%0A%2F%2F %23%23 Part Two  The parser%0A%0A%2F%2F The parsers job is to decode the input and build a collection of objects%0A%2F%2F that represent the code.%0A%2F%2F%0A%2F%2F (This is just like the way a Web browser decodes an HTML file and builds the%0A%2F%2F DOM. The part that does that is called the HTML parser.)%0A%0A%2F%2F Parse the given string %60code%60 as an expression in our little language.%0A%2F%2F%0Afunction parse(code) %7B%0A    %2F%2F Break the input into tokens.%0A    var tokens %3D tokenize(code)%3B%0A%0A    %2F%2F The parser will do a single left-to-right pass over %60tokens%60%2C with no%0A    %2F%2F backtracking. %60position%60 is the index of the next token. Start at%0A    %2F%2F 0. Well increment this as we go.%0A    var position %3D 0%3B%0A%0A    %2F%2F %60peek()%60 returns the next token without advancing %60position%60.%0A    function peek() %7B%0A        return tokens%5Bposition%5D%3B%0A    %7D%0A%0A    %2F%2F %60consume(token)%60 consumes one token%2C moving %60position%60 to point to the next one.%0A    function consume(token) %7B%0A        assert.strictEqual(token%2C tokens%5Bposition%5D)%3B%0A        position%2B%2B%3B%0A    %7D%0A%0A    %2F%2F Now we have the functions that are actually responsible for parsing.%0A    %2F%2F This is the cool part. Each group of syntax rules is translated to one%0A    %2F%2F function.%0A%0A    %2F%2F Parse a *PrimaryExpr*that is%2C tokens matching one of the three syntax%0A    %2F%2F rules below. Whatever kind of expression we find%2C we return the corresponding%0A    %2F%2F JS object.%0A    %2F%2F%0A    %2F%2F <div style%3D"margin-left%3A 2em">%0A    %2F%2F  <div>*PrimaryExpr* **%3A**<%2Fdiv>%0A    %2F%2F  <div style%3D"margin-left%3A 2em">%0A    %2F%2F   <div>*Number*<%2Fdiv>%0A    %2F%2F   <div>*Name*<%2Fdiv>%0A    %2F%2F   <div><b><code>(<%2Fcode><%2Fb> *Expr* <b><code>)<%2Fcode><%2Fb><%2Fdiv>%0A    %2F%2F  <%2Fdiv>%0A    %2F%2F <%2Fdiv>%0A    function parsePrimaryExpr() %7B%0A        var t %3D peek()%3B%0A%0A        if (isNumber(t)) %7B%0A            consume(t)%3B%0A            return %7Btype%3A "number"%2C value%3A t%7D%3B%0A        %7D else if (isName(t)) %7B%0A            consume(t)%3B%0A            return %7Btype%3A "name"%2C id%3A t%7D%3B%0A        %7D else if (t %3D%3D%3D "(") %7B%0A            consume(t)%3B%0A            var expr %3D parseExpr()%3B%0A            if (peek() !%3D%3D ")")%0A                throw new SyntaxError("expected )")%3B%0A            consume(")")%3B%0A            return expr%3B%0A        %7D else %7B%0A            %2F%2F If we get here%2C the next token doesnt match any of the three%0A            %2F%2F rules. So its an error.%0A            throw new SyntaxError("expected a number%2C a variable%2C or parentheses")%3B%0A        %7D%0A    %7D%0A%0A    %2F%2F <div style%3D"margin-left%3A 2em%3B margin-bottom%3A 1em">%0A    %2F%2F  *MulExpr* **%3A**%0A    %2F%2F  <div style%3D"margin-left%3A 2em">%0A    %2F%2F   <div>*PrimaryExpr* ( <b><code>%5C*<%2Fcode><%2Fb> *PrimaryExpr* %7C <b><code>%2F<%2Fcode><%2Fb> *PrimaryExpr* )<sup>%5C*<%2Fsup><%2Fdiv>%0A    %2F%2F  <%2Fdiv>%0A    %2F%2F <%2Fdiv>%0A    function parseMulExpr() %7B%0A        var expr %3D parsePrimaryExpr()%3B%0A        var t %3D peek()%3B%0A        while (t %3D%3D%3D "*" %7C%7C t %3D%3D%3D "%2F") %7B%0A            consume(t)%3B%0A            var rhs %3D parsePrimaryExpr()%3B%0A            expr %3D %7Btype%3A t%2C left%3A expr%2C right%3A rhs%7D%3B%0A            t %3D peek()%3B%0A        %7D%0A        return expr%3B%0A    %7D%0A%0A    %2F%2F <div style%3D"margin-left%3A 2em">%0A    %2F%2F  *Expr* **%3A**%0A    %2F%2F  <div style%3D"margin-left%3A 2em">%0A    %2F%2F   <div>*MulExpr* ( <b><code>%2B<%2Fcode><%2Fb> *MulExpr* %7C <b><code>-<%2Fcode><%2Fb> *MulExpr* )<sup>%5C*<%2Fsup><%2Fdiv>%0A    %2F%2F  <%2Fdiv>%0A    %2F%2F <%2Fdiv>%0A    function parseExpr() %7B%0A        var expr %3D parseMulExpr()%3B%0A        var t %3D peek()%3B%0A        while (t %3D%3D%3D "%2B" %7C%7C t %3D%3D%3D "-") %7B%0A            consume(t)%3B%0A            var rhs %3D parseMulExpr()%3B%0A            expr %3D %7Btype%3A t%2C left%3A expr%2C right%3A rhs%7D%3B%0A            t %3D peek()%3B%0A        %7D%0A        return expr%3B%0A    %7D%0A%0A    %2F%2F Now all that remains%2C really%2C is to call %60parseExpr()%60 to parse an *Expr*.%0A    var result %3D parseExpr()%3B%0A%0A    %2F%2F Well%2C one more thing. Make sure %60parseExpr()%60 consumed *all* the%0A    %2F%2F input. If it didnt%2C that means the next token didnt match any syntax%0A    %2F%2F rule%2C which is an error.%0A    if (position !%3D%3D tokens.length)%0A        throw new SyntaxError("unexpected '" %2B peek() %2B "'")%3B%0A%0A    return result%3B%0A%7D%0A%2F%2F %23 calculator-backends.js%0A%2F%2F%0A%2F%2F things to do with a simple calculator parser%0A%2F%2F%0A%2F%2F %5Bcalculator-parser.js%5D(calculator-parser.html) contains a simple parser.%0A%2F%2F It contains enough code that you can actually do some basic math with it.%0A%2F%2F But what else can you do with a parser%3F%0A%2F%2F%0A%2F%2F This file contains seven different applications of%0A%2F%2F the calculator parser.%0A%2F%2F%0A%2F%2F %5BTry them out.%5D(..%2Fcalculator.html)%0A%0A%2F%2F %23%23 Code as data%0A%0A%2F%2F %23%23%23 1. Show the JSON%0A%2F%2F%0A%2F%2F Unmodified%2C the parser simply builds a tree describing the input%0A%2F%2F formula. This is called an abstract syntax tree%2C or AST.%0A%2F%2F%0Afunction convertToJSON(code) %7B%0A    return parse(code)%3B%0A%7D%0A%0A%0A%2F%2F %23%23%23 2. Convert to DOM%0A%2F%2F%0A%2F%2F Of course one of the nice things about JSON is that there are many ways to%0A%2F%2F display it. Heres code that spits out DOM nodes that show how the program%0A%2F%2F would look in Scratch. (!)%0A%0A%2F%2F Helper function to create DOM elements.%0Afunction span(className%2C contents) %7B%0A    var e %3D document.createElement("span")%3B%0A    e.className %3D className%3B%0A    for (var i %3D 0%3B i < contents.length%3B i%2B%2B) %7B%0A        var kid %3D contents%5Bi%5D%3B%0A        if (typeof kid %3D%3D%3D "string")%0A            kid %3D document.createTextNode(kid)%3B%0A        e.appendChild(kid)%3B%0A    %7D%0A    return e%3B%0A%7D%0A%0Afunction convertToDOM(code) %7B%0A    var fancyOperator %3D %7B%0A        "%2B"%3A "%2B"%2C%0A        "-"%3A "%5Cu2212"%2C  %2F%2F %26minus%3B%0A        "*"%3A "%5Cu00d7"%2C  %2F%2F %26times%3B%0A        "%2F"%3A "%5Cu00f7"   %2F%2F %26divide%3B%0A    %7D%3B%0A%0A    function convert(obj) %7B%0A        switch (obj.type) %7B%0A        case "number"%3A%0A            return span("num"%2C %5Bobj.value%5D)%3B%0A        case "%2B"%3A case "-"%3A case "*"%3A case "%2F"%3A%0A            return span("expr"%2C %5Bconvert(obj.left)%2C%0A                                 fancyOperator%5Bobj.type%5D%2C%0A                                 convert(obj.right)%5D)%3B%0A        case "name"%3A%0A            return span("var"%2C %5Bobj.id%5D)%3B%0A        %7D%0A    %7D%0A    return convert(parse(code))%3B%0A%7D%0A%0A%0A%2F%2F %23%23%23 3. MathML output%0A%2F%2F%0A%2F%2F One more riff on this theme%3A How about generating beautiful MathML output%3F%0A%2F%2F (Unfortunately%2C some browsers still do not support MathML. Firefox does.)%0A%0A%2F%2F The hardest part of this was figuring out how to make MathML elements.%0A%2F%2F Heres some code to help with that.%0Avar mathml %3D "http%3A%2F%2Fwww.w3.org%2F1998%2FMath%2FMathML"%3B%0A%0Afunction mo(s) %7B%0A    var e %3D document.createElementNS(mathml%2C "mo")%3B%0A    var t %3D document.createTextNode(s)%3B%0A    e.appendChild(t)%3B%0A    return %7Bprec%3A 3%2C element%3A e%7D%3B%0A%7D%0A%0A%2F%2F Create a new MathML DOM element of the specified type and contents.%0A%2F%2F %60precedence%60 is used to determine whether or not to add parentheses around%0A%2F%2F any of the contents. If its %60null%60%2C no parentheses are added.%0Afunction make(name%2C precedence%2C contents) %7B%0A    var e %3D document.createElementNS(mathml%2C name)%3B%0A    for (var i %3D 0%3B i < contents.length%3B i%2B%2B) %7B%0A        var kid %3D contents%5Bi%5D%3B%0A        var node%3B%0A%0A        if (typeof kid %3D%3D%3D "string") %7B%0A            node %3D document.createTextNode(kid)%3B%0A        %7D else %7B%0A            %2F%2F If precedence is non-null and higher than this childs%0A            %2F%2F precedence%2C wrap the child in parentheses.%0A            if (precedence !%3D%3D null%0A                %26%26 (kid.prec < precedence%0A                    %7C%7C (kid.prec %3D%3D precedence %26%26 i !%3D 0)))%0A            %7B%0A                kid %3D make("mrow"%2C null%2C %5Bmo("(")%2C kid%2C mo(")")%5D)%3B%0A            %7D%0A            node %3D kid.element%3B%0A        %7D%0A        e.appendChild(node)%3B%0A    %7D%0A    if (precedence %3D%3D%3D null)%0A        precedence %3D 3%3B%0A    return %7Bprec%3A precedence%2C element%3A e%7D%3B%0A%7D%0A%0Afunction convertToMathML(code) %7B%0A    function convert(obj) %7B%0A        switch (obj.type) %7B%0A        case "number"%3A%0A            return make("mn"%2C 3%2C %5Bobj.value%5D)%3B%0A        case "name"%3A%0A            return make("mi"%2C 3%2C %5Bobj.id%5D)%3B%0A        case "%2B"%3A%0A            return make("mrow"%2C 1%2C %5Bconvert(obj.left)%2C%0A                                    make("mo"%2C 3%2C %5B"%2B"%5D)%2C%0A                                    convert(obj.right)%5D)%3B%0A        case "-"%3A%0A            return make("mrow"%2C 1%2C %5Bconvert(obj.left)%2C%0A                                    make("mo"%2C 3%2C %5B"-"%5D)%2C%0A                                    convert(obj.right)%5D)%3B%0A        case "*"%3A%0A            return make("mrow"%2C 2%2C %5Bconvert(obj.left)%2C%0A                                    convert(obj.right)%5D)%3B%0A        case "%2F"%3A%0A            return make("mfrac"%2C null%2C %5Bconvert(obj.left)%2C convert(obj.right)%5D)%3B%0A        %7D%0A    %7D%3B%0A    var e %3D convert(parse(code))%3B%0A    return make("math"%2C null%2C %5Be%5D)%3B%0A%7D%0A%0A%0A%2F%2F %23%23 Interpreters%0A%0A%2F%2F %23%23%23 4. Evaluate using floating-point numbers%0A%0A%2F%2F Now lets try actually performing some computation using the program we%0A%2F%2F read. This behaves like a stripped-down version of JavaScript %60eval()%60.%0Afunction evaluateAsFloat(code) %7B%0A    var variables %3D Object.create(null)%3B%0A    variables.e %3D Math.E%3B%0A    variables.pi %3D Math.PI%3B%0A%0A    function evaluate(obj) %7B%0A        switch (obj.type) %7B%0A        case "number"%3A  return parseInt(obj.value)%3B%0A        case "name"%3A  return variables%5Bobj.id%5D %7C%7C 0%3B%0A        case "%2B"%3A  return evaluate(obj.left) %2B evaluate(obj.right)%3B%0A        case "-"%3A  return evaluate(obj.left) - evaluate(obj.right)%3B%0A        case "*"%3A  return evaluate(obj.left) * evaluate(obj.right)%3B%0A        case "%2F"%3A  return evaluate(obj.left) %2F evaluate(obj.right)%3B%0A        %7D%0A    %7D%0A    return evaluate(parse(code))%3B%0A%7D%0A%0Aassert.strictEqual(evaluateAsFloat("2 %2B 2")%2C 4)%3B%0Aassert.strictEqual(evaluateAsFloat("3 * 4 * 5")%2C 60)%3B%0Aassert.strictEqual(evaluateAsFloat("5 * (2 %2B 2)")%2C 20)%3B%0A%0A%0A%2F%2F %23%23%23 5. Evaluate using precise fraction arithmetic%0A%2F%2F%0A%2F%2F Our little language is a tiny subset of JavaScript. But that doesnt meant%0A%2F%2F it has to behave exactly like JavaScript. This is our language.%0A%2F%2F It can behave however we want.%0A%0A%2F%2F So how about a calculator that does arbitrary precision arithmetic%3F%0A%2F%2F Lets start by defining a %60Fraction%60 class...%0A%0Avar BigInteger %3D biginteger.BigInteger%3B%0A%0Afunction gcd(a%2C b) %7B%0A    while (!b.isZero()) %7B%0A        var tmp %3D a%3B%0A        a %3D b%3B%0A        b %3D tmp.remainder(b)%3B%0A    %7D%0A    return a%3B%0A%7D%0A%0Afunction Fraction(n%2C d) %7B%0A    if (d %3D%3D%3D undefined)%0A        d %3D new BigInteger(1)%3B%0A    var x %3D gcd(n.abs()%2C d)%3B  %2F%2F Simplify the fraction.%0A    this.n %3D n.divide(x)%3B%0A    this.d %3D d.divide(x)%3B%0A%7D%0A%0A%2F%2F and some Fraction methods. You learned these techniques in grade school%2C%0A%2F%2F though you may have forgotten some of them.%0AFraction.prototype %3D %7B%0A    add%3A function (x) %7B%0A        return new Fraction(this.n.multiply(x.d).add(x.n.multiply(this.d))%2C%0A                            this.d.multiply(x.d))%3B%0A    %7D%2C%0A    negate%3A function (x) %7B%0A        return new Fraction(this.n.negate()%2C this.d)%3B%0A    %7D%2C%0A    sub%3A function (x) %7B%0A        return this.add(x.negate())%3B%0A    %7D%2C%0A    mul%3A function (x) %7B%0A        return new Fraction(this.n.multiply(x.n)%2C this.d.multiply(x.d))%3B%0A    %7D%2C%0A    div%3A function (x) %7B%0A        return new Fraction(this.n.multiply(x.d)%2C this.d.multiply(x.n))%3B%0A    %7D%2C%0A    toString%3A function () %7B%0A        var ns %3D this.n.toString()%2C ds %3D this.d.toString()%3B%0A        if (ds %3D%3D%3D "1")%0A            return ns%3B%0A        else%0A            return ns %2B "%2F" %2B ds%3B%0A    %7D%0A%7D%3B%0A%0A%2F%2F Now simply write an interpreter that computes the results using %60Fraction%60%0A%2F%2F objects rather than JavaScript numbers. Its almost too easy.%0Afunction evaluateAsFraction(code) %7B%0A    function evaluate(obj) %7B%0A        switch (obj.type) %7B%0A        case "number"%3A  return new Fraction(new BigInteger(obj.value))%3B%0A        case "%2B"%3A  return evaluate(obj.left).add(evaluate(obj.right))%3B%0A        case "-"%3A  return evaluate(obj.left).sub(evaluate(obj.right))%3B%0A        case "*"%3A  return evaluate(obj.left).mul(evaluate(obj.right))%3B%0A        case "%2F"%3A  return evaluate(obj.left).div(evaluate(obj.right))%3B%0A        case "name"%3A  throw new SyntaxError("no variables in fraction mode%2C sorry")%3B%0A        %7D%0A    %7D%0A    return evaluate(parse(code))%3B%0A%7D%0A%0A%2F%2F Our tiny programming language is suddenly doing something JavaScript itself%0A%2F%2F doesnt do%3A arithmetic with exact (not floating-point) results.  Tests%3A%0Aassert.strictEqual(evaluateAsFraction("1 %2F 3").toString()%2C "1%2F3")%3B%0Aassert.strictEqual(evaluateAsFraction("(2%2F3) * (3%2F2)").toString()%2C "1")%3B%0Aassert.strictEqual(evaluateAsFraction("1%2F7 %2B 4%2F7 %2B 2%2F7").toString()%2C "1")%3B%0Aassert.strictEqual(%0A    evaluateAsFraction("5996788328646786302319492 %2F 2288327879043508396784319").toString()%2C%0A    "324298349324%2F123749732893")%3B%0A%0A%0A%2F%2F %23%23 Compilers%0A%0A%2F%2F %23%23%23 6. JavaScript function output%0A%0A%2F%2F This is just to show some very basic code generation.%0A%2F%2F%0A%2F%2F Code generation for a real compiler will be harder%2C because the target%0A%2F%2F language is typically quite a bit different from the source language. Here%0A%2F%2F they are virtually identical%2C so code generation is very easy.%0A%2F%2F%0Afunction compileToJSFunction(code) %7B%0A    function emit(obj) %7B%0A        switch (obj.type) %7B%0A        case "number"%3A%0A            return obj.value%3B%0A        case "name"%3A%0A            %2F%2F Only allow the name "x".%0A            if (obj.id !%3D%3D "x")%0A                throw SyntaxError("only the name 'x' is allowed")%3B%0A            return obj.id%3B%0A        case "%2B"%3A case "-"%3A case "*"%3A case "%2F"%3A%0A            return "(" %2B emit(obj.left) %2B " " %2B obj.type %2B " " %2B emit(obj.right) %2B ")"%3B%0A        %7D%0A    %7D%0A%0A    return Function("x"%2C "return " %2B emit(parse(code)) %2B "%3B")%3B%0A%7D%0A%0Aassert.strictEqual(compileToJSFunction("x*x - 2*x %2B 1")(1)%2C 0)%3B%0Aassert.strictEqual(compileToJSFunction("x*x - 2*x %2B 1")(2)%2C 1)%3B%0Aassert.strictEqual(compileToJSFunction("x*x - 2*x %2B 1")(3)%2C 4)%3B%0Aassert.strictEqual(compileToJSFunction("x*x - 2*x %2B 1")(4)%2C 9)%3B%0A%0A%0A%2F%2F %23%23%23 7. Complex function output%0A%0A%2F%2F This one returns a JS function that operates on complex numbers.%0A%2F%2F%0A%2F%2F This is a more advanced example of a compiler. It has a lowering phase%0A%2F%2F and a few simple optimizations.%0A%2F%2F%0A%2F%2F The input string %60code%60 is a formula%2C for example%2C %60"(z%2B1)%2F(z-1)"%60%2C%0A%2F%2F that uses a complex variable %60z%60.%0A%2F%2F%0A%2F%2F This returns a JS function that takes two arguments%2C %60z_re%60 and %60z_im%60%2C%0A%2F%2F the real and imaginary parts of a complex number *z*%2C%0A%2F%2F and returns an object %60%7Bre%3A some number%2C im%3A some number%7D%60%2C%0A%2F%2F representing the complex result of computing the input formula%2C%0A%2F%2F (*z*%2B1)%2F(*z*-1). Here is the actual output in that case%3A%0A%2F%2F%0A%2F%2F     (function anonymous(z_re%2C z_im) %7B%0A%2F%2F     var t0 %3D (z_re%2B1)%3B%0A%2F%2F     var t1 %3D (z_re-1)%3B%0A%2F%2F     var t2 %3D (z_im*z_im)%3B%0A%2F%2F     var t3 %3D ((t1*t1)%2Bt2)%3B%0A%2F%2F     return %7Bre%3A (((t0*t1)%2Bt2)%2Ft3)%2C im%3A (((z_im*t1)-(t0*z_im))%2Ft3)%7D%3B%0A%2F%2F     %7D)%0A%2F%2F%0Afunction compileToComplexFunction(code) %7B%0A    %2F%2F The first thing here is a lot of code about "values". This takes some%0A    %2F%2F explanation.%0A    %2F%2F%0A    %2F%2F %60compileToComplexFunction%60 works in three steps.%0A    %2F%2F%0A    %2F%2F 1. It uses %60parse%60 as its front end. We get an AST that represents%0A    %2F%2F    operations on complex numbers.%0A    %2F%2F%0A    %2F%2F 2. Then%2C it **lowers** the AST to an *intermediate representation* (IR)%0A    %2F%2F    thats sort of halfway between the AST and JS code.%0A    %2F%2F%0A    %2F%2F    The IR here is an array of *values*%2C basic arithmetic operations on%0A    %2F%2F    plain old JS floating-point numbers. If we end up needing JS to%0A    %2F%2F    compute %60(z_re %2B 1) * (z_re - 1)%2C then each subexpression there ends%0A    %2F%2F    up being a value%2C represented by an object in the IR.%0A    %2F%2F%0A    %2F%2F    Once we have the IR%2C we can throw away the AST. The IR represents the%0A    %2F%2F    same formula%2C but in a different form. Lowering breaks down complex%0A    %2F%2F    arithmetic into sequences of JS numeric operations.  JS won't know%0A    %2F%2F    it's doing complex math.%0A    %2F%2F%0A    %2F%2F 3. Lastly%2C we convert the IR to JS code.%0A    %2F%2F%0A    %2F%2F **Why lowering%3F** We don't have to do it this way%3B we could define a%0A    %2F%2F class %60Complex%60%2C with methods %60.add()%60%2C %60.sub()%60%2C etc.%2C and generate JS%0A    %2F%2F code that uses that.  Lowering leads to faster JS code%3A we'll generate%0A    %2F%2F code here that does not allocate any objects for intermediate results.%0A%0A    %2F%2F %23%23%23%23 About the IR%0A    %2F%2F%0A    %2F%2F Before we implement lower()%2C we need to define objects representing%0A    %2F%2F values. (We could just use strings of JS code%2C but it turns%0A    %2F%2F out to be really complicated%2C and it's hard to apply even basic%0A    %2F%2F optimizations to strings.)%0A    %2F%2F%0A    %2F%2F We call these instructions "values".  Each value represents a single JS%0A    %2F%2F expression that evaluates to a number.  A value is one of%3A%0A    %2F%2F%0A    %2F%2F   1. %60z_re%60 or %60z_im%60%2C the real or imaginary part of the argument z%3B or%0A    %2F%2F   2. a numeric constant%3B or%0A    %2F%2F   3. an arithmetic operation%2C one of %60%2B - * %2F%60%2C on two previously-%0A    %2F%2F      calculated values.%0A    %2F%2F%0A    %2F%2F And each value is represented by a plain old JSON object%2C as follows%3A%0A    %2F%2F%0A    %2F%2F   1. %60%7Btype%3A "arg"%2C arg0%3A "z_re"%60 or %60"z_im"%7D%60%0A    %2F%2F   2. %60%7Btype%3A "number"%2C arg0%3A (string picture of number)%7D%60%0A    %2F%2F   3. %60%7Btype%3A (one of "%2B" "-" "*" "%2F")%2C arg0%3A (int)%2C arg1%3A (int)%7D%60%0A    %2F%2F%0A    %2F%2F All values are stored sequentially in the array %60values%60.  The two ints%0A    %2F%2F %60v.arg0%60 and %60v.arg1%60 in an arithmetic value are indexes into %60values%60.%0A    %2F%2F%0A    %2F%2F The main reason to store all values in a flat array%2C rather than a tree%2C%0A    %2F%2F is for "common subexpression elimination" (see valueToIndex).%0A    %2F%2F%0A    var values %3D %5B%0A        %7Btype%3A "arg"%2C arg0%3A "z_re"%2C arg1%3A null%7D%2C%0A        %7Btype%3A "arg"%2C arg0%3A "z_im"%2C arg1%3A null%7D%0A    %5D%3B%0A%0A    %2F%2F %60values(n1%2C n2)%60 returns true if the two arguments %60n1%60 and %60n2%60 are%0A    %2F%2F equal valuesthat is%2C if it would be redundant to compute them both%2C%0A    %2F%2F because they are certain to have the same result.%0A    %2F%2F%0A    %2F%2F (This could be more sophisticated%3B it does not detect%2C for example%2C that%0A    %2F%2F a%2B1 is equal to 1%2Ba.)%0A    %2F%2F%0A    function valuesEqual(n1%2C n2) %7B%0A        return n1.type %3D%3D%3D n2.type %26%26 n1.arg0 %3D%3D%3D n2.arg0 %26%26 n1.arg1 %3D%3D%3D n2.arg1%3B%0A    %7D%0A%0A    %2F%2F Return the index of %60v%60 within %60values%60%2C adding it to %60values%60 if needed.%0A    function valueToIndex(v) %7B%0A        %2F%2F Common subexpression elimination. If we have already computed this%0A        %2F%2F exact value%2C instead of computing it again%2C just reuse the already-%0A        %2F%2F computed value.%0A        for (var i %3D 0%3B i < values.length%3B i%2B%2B) %7B%0A            if (valuesEqual(values%5Bi%5D%2C v))%0A                return i%3B%0A        %7D%0A%0A        %2F%2F We have not already computed this value%2C so add the value to%0A        %2F%2F the list.%0A        values.push(v)%3B%0A        return values.length - 1%3B%0A    %7D%0A%0A    function num(s) %7B%0A        return valueToIndex(%7Btype%3A "number"%2C arg0%3A s%2C arg1%3A null%7D)%3B%0A    %7D%0A%0A    function op(op%2C a%2C b) %7B%0A        return valueToIndex(%7Btype%3A op%2C arg0%3A a%2C arg1%3A b %7D)%3B%0A    %7D%0A%0A    function isNumber(i) %7B%0A        return values%5Bi%5D.type %3D%3D%3D "number"%3B%0A    %7D%0A%0A    function isZero(i) %7B%0A        return isNumber(i) %26%26 values%5Bi%5D.arg0 %3D%3D%3D "0"%3B%0A    %7D%0A%0A    function isOne(i) %7B%0A        return isNumber(i) %26%26 values%5Bi%5D.arg0 %3D%3D%3D "1"%3B%0A    %7D%0A%0A    function add(a%2C b) %7B%0A        if (isZero(a))  %2F%2F simplify (0%2Bb) to b%0A            return b%3B%0A        if (isZero(b))  %2F%2F simplify (a%2B0) to a%0A            return a%3B%0A        if (isNumber(a) %26%26 isNumber(b))  %2F%2F constant-fold (1%2B2) to 3%0A            return num(String(Number(values%5Ba%5D.arg0) %2B Number(values%5Bb%5D.arg0)))%3B%0A        return op("%2B"%2C a%2C b)%3B%0A    %7D%0A%0A    function sub(a%2C b) %7B%0A        if (isZero(b))  %2F%2F simplify (a-0) to a%0A            return a%3B%0A        if (isNumber(a) %26%26 isNumber(b))  %2F%2F constant-fold (3-2) to 1%0A            return num(String(Number(values%5Ba%5D.arg0) - Number(values%5Bb%5D.arg0)))%3B%0A        return op("-"%2C a%2C b)%3B%0A    %7D%0A%0A    function mul(a%2C b) %7B%0A        if (isZero(a))  %2F%2F simplify 0*b to 0%0A            return a%3B%0A        if (isZero(b))  %2F%2F simplify a*0 to 0%0A            return b%3B%0A        if (isOne(a))  %2F%2F simplify 1*b to b%0A            return b%3B%0A        if (isOne(b))  %2F%2F simplify a*1 to a%0A            return a%3B%0A        if (isNumber(a) %26%26 isNumber(b))  %2F%2F constant-fold (2*2) to 4%0A            return num(String(Number(values%5Ba%5D.arg0) * Number(values%5Bb%5D.arg0)))%3B%0A        return op("*"%2C a%2C b)%3B%0A    %7D%0A%0A    function div(a%2C b) %7B%0A        if (isOne(b))  %2F%2F simplify a%2F1 to a%0A            return a%3B%0A        if (isNumber(a) %26%26 isNumber(b) %26%26 !isZero(b))  %2F%2F constant-fold 4%2F2 to 2%0A            return num(String(Number(values%5Ba%5D.arg0) %2F Number(values%5Bb%5D.arg0)))%3B%0A        return op("%2F"%2C a%2C b)%3B%0A    %7D%0A%0A    %2F%2F Reduce obj%2C which represents an operation on complex numbers%2C%0A    %2F%2F to a pair of expressions on floating-point numbers.%0A    function ast_to_ir(obj) %7B%0A        switch (obj.type) %7B%0A        case "number"%3A%0A            return %7Bre%3A num(obj.value)%2C im%3A num("0")%7D%3B%0A%0A        case "%2B"%3A case "-"%3A%0A            var a %3D ast_to_ir(obj.left)%2C b %3D ast_to_ir(obj.right)%3B%0A            var f %3D (obj.type %3D%3D%3D "%2B" %3F add %3A sub)%3B%0A            return %7B%0A                re%3A f(a.re%2C b.re)%2C%0A                im%3A f(a.im%2C b.im)%0A            %7D%3B%0A%0A        case "*"%3A%0A            var a %3D ast_to_ir(obj.left)%2C b %3D ast_to_ir(obj.right)%3B%0A            return %7B%0A                re%3A sub(mul(a.re%2C b.re)%2C mul(a.im%2C b.im))%2C%0A                im%3A add(mul(a.re%2C b.im)%2C mul(a.im%2C b.re))%0A            %7D%3B%0A%0A        case "%2F"%3A%0A            var a %3D ast_to_ir(obj.left)%2C b %3D ast_to_ir(obj.right)%3B%0A            var t %3D add(mul(b.re%2C b.re)%2C mul(b.im%2C b.im))%3B%0A            return %7B%0A                re%3A div(add(mul(a.re%2C b.re)%2C mul(a.im%2C b.im))%2C t)%2C%0A                im%3A div(sub(mul(a.im%2C b.re)%2C mul(a.re%2C b.im))%2C t)%0A            %7D%3B%0A%0A        case "name"%3A%0A            if (obj.id %3D%3D%3D "i")%0A                return %7Bre%3A num("0")%2C im%3A num("1")%7D%3B%0A            if (obj.id !%3D%3D "z")%0A                throw SyntaxError("undefined variable%3A " %2B obj.id)%3B%0A            %2F%2F A little subtle here%3A values%5B0%5D is z_re%3B values%5B1%5D is z_im.%0A            return %7Bre%3A 0%2C im%3A 1%7D%3B%0A        %7D%0A    %7D%0A%0A    function computeUseCounts(values) %7B%0A        var binaryOps %3D %7B"%2B"%3A 1%2C "-"%3A 1%2C "*"%3A 1%2C "%2F"%3A 1%7D%3B%0A        var useCounts %3D %5B%5D%3B%0A        for (var i %3D 0%3B i < values.length%3B i%2B%2B) %7B%0A            useCounts%5Bi%5D %3D 0%3B%0A            var node %3D values%5Bi%5D%3B%0A            if (node.type in binaryOps) %7B%0A                useCounts%5Bnode.arg0%5D%2B%2B%3B%0A                useCounts%5Bnode.arg1%5D%2B%2B%3B%0A            %7D%0A        %7D%0A        return useCounts%3B%0A    %7D%0A%0A    function ir_to_js(values%2C result) %7B%0A        var useCounts %3D computeUseCounts(values)%3B%0A        var code %3D ""%3B%0A        var next_temp_id %3D 0%3B%0A        var js %3D %5B%5D%3B%0A        for (var i %3D 0%3B i < values.length%3B i%2B%2B) %7B%0A            var node %3D values%5Bi%5D%3B%0A            if (node.type %3D%3D%3D "number" %7C%7C node.type %3D%3D%3D "arg") %7B%0A                js%5Bi%5D %3D node.arg0%3B%0A            %7D else %7B%0A                js%5Bi%5D %3D "(" %2B js%5Bnode.arg0%5D %2B node.type %2B js%5Bnode.arg1%5D %2B ")"%3B%0A                if (useCounts%5Bi%5D > 1) %7B%0A                    var name %3D "t" %2B next_temp_id%2B%2B%3B%0A                    code %2B%3D "var " %2B name %2B " %3D " %2B js%5Bi%5D %2B "%3B%5Cn"%3B%0A                    js%5Bi%5D %3D name%3B%0A                %7D%0A            %7D%0A        %7D%0A        code %2B%3D "return %7Bre%3A " %2B js%5Bresult.re%5D %2B "%2C im%3A " %2B js%5Bresult.im%5D %2B "%7D%3B%5Cn"%3B%0A        return code%3B%0A    %7D%0A%0A    var ast %3D parse(code)%3B%0A    var result %3D ast_to_ir(ast)%3B%0A    var code %3D ir_to_js(values%2C result)%3B%0A    console.log(code)%3B%0A    return Function("z_re%2C z_im"%2C code)%3B%0A%0A    %2F*%0A      I had planned to have this generate asm.js code for extra speed%2C but it's%0A      so fast already that unless I can think of a more computationally%0A      intensive task%2C there is no need.%0A    *%2F%0A%7D%0A%0A%2F%2F The last bit of code here simply stores all seven back ends in one place%0A%2F%2F where other code can get to them.%0Avar parseModes %3D %7B%0A    json%3A convertToJSON%2C%0A    blocks%3A convertToDOM%2C%0A    mathml%3A convertToMathML%2C%0A    calc%3A evaluateAsFloat%2C%0A    fraction%3A evaluateAsFraction%2C%0A    graph%3A compileToJSFunction%2C%0A    complex%3A compileToComplexFunction%0A%7D%3B%0A%0Afunction evaluateAsFloat(code) %7B%0A    var variables %3D Object.create(null)%3B%0A    variables.e %3D Math.E%3B%0A    variables.pi %3D Math.PI%3B%0A%0A    function evaluate(obj) %7B%0A        switch (obj.type) %7B%0A        case "number"%3A  return parseInt(obj.value)%3B%0A        case "name"%3A  return variables%5Bobj.id%5D %7C%7C 0%3B%0A        case "%2B"%3A  return evaluate(obj.left) %2B evaluate(obj.right)%3B%0A        case "-"%3A  return evaluate(obj.left) - evaluate(obj.right)%3B%0A        case "*"%3A  return evaluate(obj.left) * evaluate(obj.right)%3B%0A        case "%2F"%3A  return evaluate(obj.left) %2F evaluate(obj.right)%3B%0A        %7D%0A    %7D%0A    return evaluate(parse(code))%3B%0A%7D%0Avar evald %3D evaluateAsFloat(prompt("What do I calculate%3F"%2C"5%2F((1%2F1)*10)"))%3B%0Aconsole.log(evald)%3B%0Acbto(evald)%3B%7D)()%3B
